
二、TCP连接（三次握手/四次挥手）
报文中字段解释：
 1） 序号：seq序号，占32位，用来标识从TCP源端向目地端发送的字节流
 2） 确认号 ack号，占32位，期待收到对方下一个报文段的第一个数据字节的序号。
 3）标识位 （flags）共6哥，即URG,ACK,PSH,RST,SYN,FIN等。具体含义如下
 	（A）URG：紧急指针（urgent pointer）有效，值为1时表示某一位需要优先处理。
	（B）ACK：确认序号有效，一般为1。
	（C）PSH：接收方应该尽快将这个报文交给应用层。
	（D）RST：重置连接。
	（E）SYN：请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1。
	（F）FIN：发送断开连接请求。

1、三次握手

	三次握手 其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的
	接收能力和发送能力是否正常，指定自己的初始化序列号为后面的可靠性传送做准备。

	三次握手过程：

	1、第一次握手：
		客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN，此时客户端处于SYN_SEND状态 （
	首部的同步位SYN=1 ，初始化序号seq=x，SYN=1的报文段不能携带数据，但是要消耗掉一个序号）
	2、第二次握手
		服务器收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化序列号ISN。同时把客户端的ISN+1
		作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_REVD状态。
		在确认报文段中，SYN=1，ACK=1，确认号ack=x+1,初始化序号 seq=y
	3、第三次握手
		客户端收到SYN报文之后，会发送一个ACK报文，把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时
		客户端处于ESTABLISHED 状态。服务器收到ACK报文之后也处于ESTABLISHED状态，此时双方已建立起了连接。

		确认报文段：ACK=1，确认号ack=y+1,序号seq=x+1 (初始为seq=x,第二个报文段所以要+1),ack报文段可以携带数据，
		不携带数据则不消耗序号。

		在socket编程中，客户端执行connect()时，将触发三次握手，并在accept()函数中完成握手连接

		流程图参考：
			https://pic3.zhimg.com/80/v2-2a54823bd63e16674874aa46a67c6c72_1440w.jpg


	1.1、 为什么需要三次握手，两次不行吗？
	第一次握手：客户端发送网络包，服务端收到了。
	这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
	第二次握手：服务端发包，客户端收到了。
	这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力
	是否正常。
	第三次握手：客户端发包，服务端收到了。
	这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
	因此，需要三次握手才能确认双方的接收与发送能力是否正常

	1.2 什么是半连接队列？
		服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。
		当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。
	 补充：关于SYN-ACK 重传次数的问题：
		服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

	1.3 三次握手过程中可以携带数据吗？
		其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据
		为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。
		也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED
		状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

2、四次挥手

		建立一个连接需要三次握手，而终止一个连接需要经过四次挥手，这是由于TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另外一端数据的能力。
		TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。
		刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。

		四次挥手的过程如下：

		第一次挥手：
			客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1 状态。
		即发出连接释放报文段（FIN=1，序号seq=u）,并停止在发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待
		服务端的确认。

		第二次挥手：
			服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1 作为ACK报文的序列号值，表明已经收到了客户端的报文了，
			此时服务端处于CLOSE_WAIT状态。

			即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

		第三次挥手：
			如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
			即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

		第四次挥手
			客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

			即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

			说明：
				收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

				在socket编程中，任何一方执行close()操作即可产生挥手操作。
			流程图参考：https://pic2.zhimg.com/80/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg

	2.1 挥手为什么四次
            由于Tcp是连接是全双工的，允许数据在两个方向上同时传输。客户端和服务端的两次挥手，也就是客户端和服务端分别释放连接的过程，
            客户端在最后一次确认之后，还要等待2MSL的时间，主要有两个原因，一个是为了让B能够按照正常步骤进入CLOSED状态。二是为了防止
            已经失效的请求报文出现在下次请求中。 （可以介绍2.2为什么要等待）

    2.2 四次挥手释放连接时，等待2MSL的意义? 和 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？
    		说明：MSL可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

    		理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。
    		所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

    		等待2MSL的主要目的总结：
    			1、保证客户端发送的最后一个ACK报文段能够到达服务端。
    				为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，
    				接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

    			2、防止“已失效的连接请求报文段”出现在本连接中。
    				客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

    2.3 三次握手时失败了会发生什么？
            1、说明在第二次握手正常，客户端和服务器端接口和发送能力正常。并且客户端已经是established状态，连接建立成功，可以单方面的向服务器TCP发送数据。
            2、第三次握手失败，服务器迟迟没有收到ACK,他的默认状态就是SYN_RCVD。并且根据TCP的超时重传机制，会等待，3，6，12秒重新发送第二组握手的分组，
            以便客户端重新发送第三次分组。若干次后服务器还没有收到ACK应答，那么服务器将会关闭这个连接。
            3、如果在第三次握手的ACK丢失的情况下客户端向服务端发送了数据，那么服务端将会以（RST包 重置响应）

    2.4 Tcp 为什么可靠

    1、Ack确认机制 和Seq 保证（消息顺序和可靠性） （可介绍三次握手和四次挥手）
    2、TCP超时重传机制
    	在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据
    3、流量控制
    	参见流程控制总结

    4、拥塞控制
    	参见拥塞控制总结

补充知识：
    OSI七层模型：
        应用层 -》 表示层 =》 会话层 -》传输层 -》网络层 -》数据链路层 -》wulic

     TCP/IP 概念层模型
        应用层 -》 传输层（TCP/UDP协议）-》网络层 -》 链路层


TCP/IP 和 HTTP/HTTPS 区别

1、TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。
    eg: 比如你需要访问一个网页，浏览器会先生成HTTP的数据包，然后交给传输层去建立连接。

HTTP 和 HTTPS

1、什么是HTTPS
	HTTPS是在HTTP上建立SSL/TLS加密层，并对传输数据进行加密，是HTTP协议的安全版。

2、HTTP存在的问题

	1、HTTP通信使用明文（不加密），内容可能被窃听。

	2、HTTP 无法验证报文的完整性，可能遭篡改

		所谓报文的完整性也是指报文信息的准确度。由于HTTP协议无法证明你通信的报文完整性，因此，在请求或响应送出之后直到对方
		接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。

	3、HTTP无法验证通信双方的身份，因此可能遭遇伪装。
		HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。
		另外，服务器只要接收到请求，不管对方是谁都会返回一个响应。因此，HTTP协议无法验证通信双方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，而用户无法擦觉。


3、HTTPS解决了上述问题
	1、数据隐私性。（内容经过对成加密，每个连接生成一个唯一的加密密钥）
	2、数据完整性。（内容传输经过完整性校验）
	3、身份认证。（第三方无法伪造服务端（客户端）身份）



4、HTTP和HTTPS 层次

	HTTP(传输层协议)					HTTPS（传输层协议）
	TCP                             SSL/TLS
	IP                              TCP
									IP


   HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL协议的功能实现主要依赖于三类基本算法。散列函数，对称机密和非对称加密。
   1、利用非对称加密实现身份认证和密钥协商
   2、利用对称加密算法采用协商的密钥对数据进行加密
   3、基于散列函数验证信息的完整性。

   参考结构图：
   https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/TLS:SSL%E6%B5%81%E7%A8%8B%E5%9B%BE.png



5、HTTPS解决内容可能被窃听的问题 - 加密
	HTTPS 使用对称加密+ 非对称加密 两者并用的混合加密机制
	具体做法： 发送密文的一方使用对方的公钥进行加密处理 ”对称的密钥“，然后对方用自己的私钥解密拿到”对称的密钥“，这样可以确保
	交换的密钥是安全的前提下，使用对称加密方式进行通信。



6、解决报文可能遭篡改问题 - 数字签名
	HTTPS使用 数字签名，解决报文可能被篡改。
	具体流程：
		1、发送者将一段报文先用HASH 函数生成消息摘要，然后用发送着的私钥加密生成数字签名。并且将数字签名与原报文一起发送给接收者。
		2、接送着用发送者的公钥解密被加密的摘要信息，然后用HASH函数对接收到的原文生成一个摘要信息，并与上一步接收到的摘要信息进行对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。


7、解决通信方身份可能被伪装的问题 —— 数字证书
	HTTPS使用 数字证书 解决通信方身份可能被伪装的问题
	数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上

	我们来介绍一下数字证书认证机构的业务流程：

	1、服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;

	2、CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;

	3、如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;

	4、客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;

	5、客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。

	6、客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法


8、HTTPS工作流程

	参考流程图：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/https%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg
	1.Client发起一个HTTPS（比如 https://juejin.im/user）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。

	2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。

	3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。

	4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。

	5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。

	6.Server使用对称密钥加密“明文内容A”，发送给Client。

	7.Client使用对称密钥解密响应的密文，得到“明文内容A”。

	8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。



 9、补充知识 对称加密和非对称加密
 	非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。
 	非对称加密效率低。

10、TCP流量控制和拥塞控制 区别。

1、流量控制
	1、什么是流量控制
		如果发送者发送数据过快，接受者来不及接收，那么就会出现分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制的根本目的是防止分组丢失，它是TCP可靠性的一方面。

	2、如何实现流量控制
		由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错，有序接收，也实现了流量控制。主要的方式就是接收方返回的ACK中会包含自己的接收窗口的大小，并列利用大小来控制发送方的数据传送。

	3、流量控制引发的死锁？怎么避免死锁的发生。

		1、当发送者接收到了一个rwnd=0(通知窗口)的应答时，发送者便停止发送，等待接收者的下一个应答。但是如果下一个rwnd 不等于0 的应答在传输过程中丢失了，发送者就会一直等待下去，而接收者以为发送者已经收到该应答，也等待接收新的数据，这样双方就互相等待，从而产生思索。
		2、解决死锁。
			为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个rwnd=0的应答时就会启动该计时器。时间一到便主动发送报文询问接收者新的rwnd窗口大小。若接收者仍然返回rwnd=0，则重置计时器继续等待，若rwnd 不等于0，则表示应答报文丢失了，此时重置发送窗口开始发送，这样就避免了死锁。

2、拥塞控制
	拥塞控制时作用于网络的，它主要是防止过多数据注入到网络中，避免出现网络负载过大的情况。
	常用的方法就是：
	  1、慢开始：刚开始建立连接的时候，发送窗口大小为1，然后逐步增加窗口的大小，如每次加倍。
	  	发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。
		慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

	  2、拥塞避免：当发送窗口达到一个门限值之后，窗口大小不再每次加倍，而是每次+1，减缓窗口增大速度。

	  总结 1和2
	  		为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：
	  		1、当cwnd<ssthresh时，使用慢开始算法。
			2、当cwnd>ssthresh时，改用拥塞避免算法。
			3、当cwnd=ssthresh时，慢开始与拥塞避免算法任意

	  3、快重传： 快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期，这是因为此时网络状况良好，可以立即重传。

	  4、快恢复：
	    快速恢复(Fast Recovery)
        （1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
        （2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），
            而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。


1、浏览器输入URL 返回页面的全过程 （分别介绍八大步骤）

	1.根据域名，进行DNS域名解析；
	2.拿到解析的IP地址，建立TCP连接；
	3.向IP地址，发送HTTP请求；
	4.服务器处理请求；
	5.返回响应结果；
	6.关闭TCP连接；
	7.浏览器解析HTML；
	8.浏览器布局渲染；

场景：用户在浏览器输入网址：http://live.qq.com，其解析过程如下


1、DNS域名解析
	先介绍域名结构
		1、http://live.qq.com 实际的域名是 http://live.qq.com.
		根域名(.) => 顶级域名(.com 或者.net) => 次级域名.qq => live(三级域名或者主机名，用户可以自行注册的)

	1、浏览器将会检查缓存中有没有这个域名对应的解析过的IP地址，如果有该解析过程
	将会结束
	2、如果用户的浏览器中缓存中没有，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射关系，完成域名解析。
	3、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系或缓存信息，如果有，直接返回给浏览器，完成域名解析。
	4、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，则会首先找本地DNS服务器，一般是公司内部的DNS服务器，此服务器收到查询，如果此本地DNS服务器查询到相对应的IP地址映射或者缓存信息，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
	5、若没有，则操作系统将域名发送至 本地域名服务器- -（递归查询方式），本地域名服务器 查询自己的DNS缓存，查找成功则返回结果，否则，（以下是迭代查询方式）

		5.1 本地域名服务器 向根域名服务器（其虽然没有每个域名的具体信息，但存储了负责每个域，如com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，根域名服务器返回com域的顶级域名服务器的地址

		5.2 本地域名服务器 向com域的顶级域名服务器发起请求，返回baidu.com权限域名服务器（权限域名服务器，用来保存该区中的所有主机域名到IP地址的映射）地址

		5.3 本地域名服务器 向baidu.com权限域名服务器发起请求，得到www.baidu.com的IP地址

    6、本地域名服务器 将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来

	7、操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来

	至此，浏览器已经得到了域名对应的IP地址。

2、拿到解析的IP地址，建立TCP连接；（叙述三次握手流程）

3、向IP地址，发送HTTP请求；
	    浏览器会对请求进行包装，包装成请求报文.使用Get/Post等请求方式进行请求。

4、服务器收到请求并响应HTTP请求
	此步骤一般nginx 会做 反向代理和 负载均衡

	1、正向代理 和 反向代理
		1、正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。

		demo: vpn 就是一种正向代理。VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机
		2、反向代理
			1、反向代理和正向代理的区别就是：正向代理代理客户端，反向代理代理服务器。
			2、反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。

	2、负载均衡
		nginx 一般使用轮询 和权重  将请求分配到不同的服务器上。

	3、浏览器请求报文到达服务器之后，服务器接口会对请求报文进行处理，执行接口对应的代码，处理完成后响应客户端。
5、服务器返回结果

	需要关注一个报文头--accept。accept代表发送端（客户端）希望接受的数据类型，这是浏览器自动封装的请求头。如果服务器返回的content-type是accept中的任何一个，浏览器都能解析，并直接展示在网页上。

	顺道介绍一下状态码： 1xx,2xx,3xx,4xx,5xx。

6、关闭TCP连接（叙述四次握手）

7.浏览器解析HTML 和 8.浏览器布局渲染；
    浏览器




11、Http2.0协议

1、HTTP1.X 存在的问题
	1、HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
	2、单向请求，只能由客户端发起。
	3、请求报文与响应报文首部信息冗余量大。
	4、数据未压缩，导致数据的传输量大

2、HTTP2.0

	1、二进制分帧
	在不改变HTTP1.x的语义、方法、状态码、URL以及首部字段的情况下.
	HTTP2.0是在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。
	在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。

	HTTP2.0 -> BinaryFraming -> TSL -> TCP -> IP

	2、首部压缩
		1、HTTP1.1并不支持HTTP首部压缩 在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。

		2、在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值
	3、多路复用
		在HTTP1.x中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。

		HTTP2.0中,基于二进制分帧层，HTTP2.0可以在共享TCP连接的基础上同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。 通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。

	4、 服务器推送
		HTTP2.0新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。

		在HTTP2.0中，服务器可以对一个客户端的请求发送多个响应。如果一个请求是由你的主页发送的，服务器可能会响应主页内容、logo以及样式表，因为他知道客户端会用到这些东西。这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。
		推送的缺点：所有推送的资源都必须遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方的确认才行。



12、Get 和Post的 区别
   在客户端和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。
   (1)GET - 从指定的资源请求数据。查询字符串 键值对 是在 GET 请求的 URL 中发送的。
   (2)POST - 向指定的资源提交要被处理的数据。查询字符串 键值对 是在 POST 请求的HTTP消息主体(request body)中发送的
   3 get请求发一次tcp包，post请求发两次tcp包。get把所有数据一次性发送给服务器，
     post第一次先发包含请求头的tcp包，服务器返回状态码100，
    表示服务器收到了请求的初始部分，请客户端继续发送，第二次发包含请求体的tcp包。 （浏览器的行为,火狐浏览器就不这样）
   4.get请求方式参数通过"?"拼接在url后，post请求方式参数放在请求体中。
   5.get请求方式长度有限制，一般在2K~4K，而post请求方式长度不限。（浏览器限制）
   6.get请求方式参数是在url中是可见的，post需要捉包才能看到参数，后者相对来讲安全性好一些。 （post不可见，但是http都是不安全的，要想安全必须使用https）
   7.get是幂等的，而post不是幂等的



14、http长连接、短连接
http长连接、短连接
在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。

而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：Connection:keep-alive。

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。
Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接

15、HTTP请求报文和HTTP响应报文。
    HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。
    HTTP有两类报文：请求报文和响应报文。
    1、一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，
        1、请求行（request line）
             请求方法，URL(包括参数信息)，协议版本这些信息（GET /admin_ui/rdx/core/images/close.png HTTP/1.1）
        2、请求头部(Header)是一个个的key-value值，
            HTTP 常见 Header
            Content-Type：数据类型（text/html 等）
            Content-Length：Body 长度
            Host：客户端告知服务器，所请求的资源在哪个主机的端口上；
            User-Agent：声明用户的操作系统和浏览器版本信息
            referer：当前页面是从哪个页面跳转过来的
            location：搭配 3XX 状态码使用，告诉客户端接下来要去访问哪里
            Cookie：用于在客户端存储少量信息，通常用于实现会话 session 的功能
        3、空行
            最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。
        4、请求数据
            请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。
            与请求数据相关的最常使用的请求头是Content-Type和Content-Length。


    2、响应报文
        响应报文 包括四部分： 状态行，消息报头，空行，响应体
          1、状态行也由三部分组成：服务器HTTP协议版本，响应状态码，状态码的文本描述
                13、状态码
                    1xx     接收的请求正在处理
                    2xx     请求正常处理完毕
                    3xx     重定向
                    4xx     客户端错误
                    5xx     服务端错误

                    100  服务器收到了请求，客户端继续发送
                    200  请求成功
                    301  永久重定向，
                    302  临时重定向
                    401  当前请求需要用户验证
                    403  服务器已经得到请求，但是拒绝执行
                    404  资源不存在
                    405  客户端请求中的方法被禁止
                    414  请求的url过长
                    500  服务器内部错误
                    503  由于超载或者系统维护，服务器暂时没有办法处理客户端的请求



