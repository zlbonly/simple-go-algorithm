分布式事务



分布式：一个业务拆分成多个子业务，每个子业务分别部署在不同的服务器上。每个子系统被称为服务。这些子系统独立运行，之间通过rpc/http进行通信
微服务：微服务的设计是为了不因为某个模块的升级和Bug影响现有的业务系统，即将模块功能进行拆分。


分布式：分散压力
微服务：分散能力

分布式一定是微服务，微服务不一定是分布式。
分布式的定义：把一个服务拆分成多个子服务，分别放在不同的服务器上。微服务可以放在同一个服务器上，也可以放在不同的服务器上。


集群：同一个业务，部署在多个服务器上


分布式 主要为了解决 高并发问题，
集群主要为了解决 高可用问题。





一、
1、分布式ID（雪花算法）
2、分布式锁（redis/zookper/etcd）
3、分布式事务
4、分布式缓存(参考 https://github.com/zlbonly/geecache )




四、分布式缓存实现 自实现（参照groupcache）

1、FIFO 先进先出
	队列：队列是一种特殊的线性表，只允许在队头进行删除元素，在队尾进行插入。

2、缓存淘汰（失效）算法。FIFO,LFU 和LRU
	概述： 
	GeeCache 的缓存全部存储在内存中，内存是有限的，因此不可能无限制地添加数据。假定我们设置缓存能够使用的内存大小为 N，那么在某一个时间点，添加了某一条缓存记录之后，占用内存超过了 N，这个时候就需要从缓存中移除一条或多条数据了。那移除谁呢？我们肯定希望尽可能移除“没用”的数据，那如何判定数据“有用”还是“没用”呢？
  
  2.1 
  	FIFO (First In  First Out) 先进先出
  	先进先出，也就是淘汰缓存中最老（即最早）添加的的记录。FIFO认为，最早添加的记录，其不再被使用的可能性难过比刚添加的可能性大。这种算法的实现比较简单，创建一个队列，新增记录添加到队尾，每次内存不够时，淘汰队首。但是很多场景中，部分记录虽然最早被添加，但是也是最常被访问的，而不得不因为待的时间太长而被淘汰。这类数据会被频繁的添加进缓存中，又被淘汰出去。导致缓存命中吕降低。
  
  2.2 
  	LFU (Least Frequently Used) 最少使用
  	最少使用。也就淘汰缓存中访问频率最低的记录。LFU认为，如果数据过去被访问多次，那么将来被访问的频率也更高。LFU的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序，淘汰时选择访问次数最少的即可。LFU算法的命中率是比较高的，但是缺点也比较明显，维护每个记录的访问次数，对内存的消耗是很高的；另外，如果数据的访问模式发生变化，LFU需要较长的时间去适应，也就是说LFU算法受历史数据的影响比较大。例如：某个数据历史上访问次数奇高，但是在某个时间点之后就不再被访问了，但是因为历史访问次数过高，而迟迟不能被淘汰。

  2.3 
  	LRU (Least Recently Used)
  	最近最少使用。相对于仅考虑时间因素的FIFO 和 仅考虑访问频率的LFU，LRU算法可以认为是相对平衡的一种淘汰算法。LRUR认为
  	如果数据最近被访问过，那么将来被访问的频率也会更高。LRU算法的实现非常简单。维护一个队列，如果某条记录被访问了，则移动到队尾，
 	那么队首则是最近最少访问的数据了，淘汰该记录就行。

  2.4 LRU 算法实现

  数据结构：字典 key-value，例如： map[key]value 和 双向链表
  说明： 1、字典map，存储键和值的映射关系。这样可以根据某个键（key）查找对应的值value的复杂度是O(1)，在字典中插入一条记录的复杂		  度也是O(1)
        2、使用双向链表实现队列。将所有的值放到双向链表中，这样，访问到某个值时，将其移动到队尾的时间复杂度是O(1)，在队尾新增一条记录以及删除一条记录的复杂度均为O（1）。


    具体实现参照：(https://github.com/zlbonly/simple-go-algorithm/blob/master/lru/lru.go 和 https://geektutu.com/post/geecache.html）
   	2.4.1 数据结构定义
   		
	2.4.2 查找
	如果键对应的链表节点存在，则将对应节点移动到队尾，并返回查找到的值。
c.ll.MoveToFront(ele)，即将链表中的节点 ele 移动到队尾（双向链表作为队列，队首队尾是相对的，在这里约定 front 为队尾）

	2.4.3  删除
	c.ll.Back() 取到队首节点，从链表中删除。
delete(c.cache, kv.key)，从字典中 c.cache 删除该节点的映射关系。
更新当前所用的内存 c.nbytes。
	2.4.4 新增
	如果键存在，则更新对应节点的值，并将该节点移到队尾。
不存在则是新增场景，首先队尾添加新节点 &entry{key, value}, 并字典中添加 key 和节点的映射关系。
更新 c.nbytes，如果超过了设定的最大值 c.maxBytes，则移除最少访问的节点。

