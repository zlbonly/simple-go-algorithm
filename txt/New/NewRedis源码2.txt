1、String 类型
	1、SDS 动态字符串
		Redis没有直接使用 C 语言的字符串，而是自己创建了名为 SDS (simple dynamic string, SDS) 的字符串。
		struct sdshdr {
	        int len; //存长度
	        int free; //存字符串内容的柔性数组的剩余空间
	        char buf[]; //柔性数组，真正存放字符串值
	    };

	    1、len 字符串长度
	    2、free 记录buff数组中未使用字节的数量
	    3、buf 字节数组，保存字符串

	2、SDS优点
		1、二进制安全
			C 语言中，用 “\0” 表示字符串的结束，如果字符串本身就有 “\0” 字符，字符串就会报截断，是非二进制安全的。
			SDS 使用len 字段记录字符串长度，读写字符串时不依赖“\0”终止符，保证了二进制安全.
		2、获取字符串长度时，只需要获取len属性的值，复杂度为O(1)
		3、减少修改字符串时带来的内存重分配次数。
			 1、常规C字符串，再执行拼接操作或者截断操作时，通常会对数组进行内存重分配。 Redis作为数据库，会对数据进行频繁的修改，并且对速度要求极为严苛，所以每次修改字符串长度都需要进行内存重分配会对性能造成极大的影响。
			  因此，SDS实现了空间预分配和惰性空间释放两种优化策略

			 2、空间预分配
			 	1、SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间
			 	2、如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配 13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。

				3、如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。

			 3、惰性空间释放
			 	当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。

	3、SDS缺点
		1、不同的 SDS字符串占用了相同大小的头部空间（buf和len长度），浪费额外的空间。
		2、Redis 5.0改进了SDS，将根据字符串的长度，分成了5种类型sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64。
			（1）五种类型都多了一个flags字段，但sdsdr5没有了头部（len和free ）
			（2）sdshdr5结构中，flags占1个字符，其低3位表示结构体类型，高5位表示长度，能表示的长度区间为0~31，flags后面就是字符串的内容。而长度大于31的字符串，1个字节存不下，那么就要将len和free单独存放，因此redis存放数据时会先检查字符串长度，再根据字符串长度计算好不同类型的头部和初始长度，然后动态分配内存

	4、为什么要用柔性数组？
       	 柔性数组的地址和结构体是连续的，这样查找内存更快（因为不需要额外通过指针找到字符串的位置）；
   		 可以更快的通过柔性数组的首地址偏移得到结构体首地址，进而能很方便的获取其余变量。

2、List
	1、Redis 列表list使用两种数据结构作为底层实现
		1、压缩列表ziplist
		2、双向链表linkedlist

			因为双向链表占用的内存比压缩列表要多， 所以当创建新的列表键时， 列表会优先考虑使用压缩列表， 并且在有需要的时候， 才从压缩列表实现转换到双向链表实现
		3、当列表对象可以同时满足下列两个条件时，列表对象采用压缩链表编码：
		（1）列表对象保存的所有字符串元素的长度都小于64字节；
		（2）列表元素保存的元素数量小于512个；
	3、ziplist
		1、压缩列表由一系列经Redis特殊编码的连续内存块组成，每一个内存块称为一个节点（entry），而一个压缩列表可以包含很多个节点。每个节点存储的数据格式可以是字节数组（中文字符串等都会转换为字节数组）或者整数值。
		2、结构：
			1、ziplist
				  字节数组（Redis使用字节数组表示一个压缩列表，字节数组逻辑划分为多个字段）
	            zlbytes | zltail | zllen | entry1 | entry2 | ......zlend

	            1、zlbytes：表示整个压缩链表所占用内存的长度（以字节为单位），占4个字节，因此压缩列表最长(2^32)-1字节；
	            2、zltail：该字段固定是一个四字节的无符号整数，用于表示在链表中最后一个节点的偏移字节量，借助这个字段，我们不 需要遍历整个链表便可以在链表尾部执行Pop操作。；
	            3、zllen：压缩列表的元素数目，占两个字节；那么当压缩列表的元素数目超过(2^16)-1怎么处理呢？此时通过zllen字段无法获得压缩列表的元素数目，必须遍历整个压缩列表才能获取到元素数目；
	            4、entryX：压缩列表存储的若干个元素，可以为字节数组或者整数；entry的编码结构后面详述；
	            5、zlend：压缩列表的结尾，占一个字节，恒为0xFF。

	        2、压缩列表节点
	           每个压缩列表节点都是由 previous_entry_length ,encoding,content三个部分组成。
	            i) previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度。
	                主要用于压缩列表遍历（使用指向当前节点起始节点指针C，减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个
	                节点起始地址的指针p）。
	            ii） encoding： 这个字段用于表示该节点使用的编码方式，具体是按照整形数进行编码还是按照字符串进行编码， 当节点使用的是字符串编码时，该字段还会指明字符串数据的字节长度。
	            iii) content : 节点保存的值 （可以是字节数组/整数），具体类型和长度 由节点encoding属性决定。

		3、优缺点：
			1、优点
				1、节省内存
				2、可以在O(1) 时间内进行push和pop操作
			2、缺点
				1、插入、删除、更新时存在内重新分配
				2、存在连锁更新问题
					因为每个节点都保存了前一个节点的长度，如果发生了更新或者删除节点。则这个节点之后的数据也需要修改，有一种最坏的情况就是如果每个节点都处于需要扩容的零界点，就会造成这个节点之后的节点都要修改 size 这个参数，引发连锁反应。这个时候就是 压缩链表最坏的时间复杂度 O(n^2)。不过所有节点都处于临界值

3、hash
	1、hashtable （dict）

4、zset
	1、ziplist
	2、skiplist