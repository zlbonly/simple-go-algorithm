
1、RPC框架流程原理
    1、服务消费方(client)以本地调用方式调用服务
    2、client stub 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体
    3、client stub 将消息进行编码并发送到服务端
    4、server stub 收到消息后进行解码
    5、server stub 根据解码结果调用本地的服务
    6、本地服务执行并将结果返回给 server stub
    7、server stub 将返回导入结果进行编码并发送至消费方
    8、client stub 接收到消息并进行解码
    9、服务消费方(client)得到结果

    参考：链接：https://juejin.cn/post/6992867064952127524

2、GRPC的流程原理 同1 类似
    1、grpc 的Stub层，通过protobuf3协议,定义好服务接口、参数等生成.proto文件，通过工具protoc-gen-go生成客户端和服务端共用的对照表，
        想生成什么语言文件就用相应的插件，这样就实现了跨语言。
    2、gRPC RPCRuntime层基于HTTP/2，将调用网络包发送到服务器
    3、GRPC Server端。启动服务，并调用服务注册相关的方法。
    4、grpc 客户端。建立连接和绑定实现的接口

3、grpc的通信协议： protobuf3
        1、protobuf支持的字段类型
            如int32、int64、uint32、uint64、sint32、sint64、bool和enum，采用可变长编码，即varints。 可变长编码。
            sin32: 可变长编码，存储负数时建议使用
            bool： 布尔类型
            string : 字符串类型
            float: 固定占用4个字节，
            double：固定占用8个字节

        2、Protobuf原理
            protobuf会对proto协议文件进行序列化，最终转换成二进制数据，在这个转换过程中，protobuf做了一些优化，使得转换出来的二进制数据尽可能的小，同时也具有安全，编解码快等特点

            1、消息类型编码
                我们定义了一个Animal的消息类型，那protobuf是怎么把它编码成二进制的呢？
                1、其实它是把message转成一系列的key-value，key就是字段号，value就是字段值，大概这样子存：
                [tag1][value1][tag2][value2][tag3][value3]...
                2、解码时，会从左往右解析每一个key-value，假如遇到某个key-value无法解析了，那么就直接跳过，不会影响到其它key-value的解析。
                另外注意到，实际上存储的是tag-value，而不是key-value，根据key转换成tag，也是有公式的
                tag = (key << 3) | wire_type
                3、value也不是直接转成二进制就完事的，它会针对不同的数据类型做不过压缩编码
                    1、可变长编码类型
                            如int32、int64、uint32、uint64、sint32、sint64、bool和enum，采用可变长编码，即varints。 可变长编码。
                            Varint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示：1010 1100 0000 0010。


                    2、负数可变长编码类型
                        如果要表示的数是一个负数，采用上面所说的方式编码，就会占用很多字节，因为对于比较常用（数值比较大）的负数来说，转成补码后会有很多个1，也就是说占用的字节会比较多，
                        ，因此Google又新增加了一种数据类型，叫sint，专门用来处理这些负数，其实现原理是采用zigzag编码，zigzag编码的映射函数为：
                        ZigZag(n) = (n << 1) ^ (n << k)，k为31或者63
                            最终的效果就是把所有的整数映射为正整数，比如0->0, -1->1, 1->1, -2->3这样子，然后就可以用上面所说的编码方式进行编码了，解码时通过逆函数解析即可
                    3、固定字节数类型
                        这种就很简单了，直接固定字节数就行，比如fixed32，它固定占用4个字节。而且可以看到，protobuf中float和double也是固定占用4个字节和8个字节，并没有实现压缩。

                    4、string类型
                        按照固定的格式编码，格式为：value = length + content
                        其中length就是content占用的字节数，采用可变长编码，content就是string的具体内容。

        3、Protobuf优缺点

            优点：
            1、小：生成的字节流采用了各种压缩方式，相对xml和json这类文件更小。
            2、快：编解码基本都是位运算，也没有复杂的嵌套关系，速度快。
            3、安全：这里的安全，是指protobuf没有把字段名写入到字节流里，只是写入了字段号信息。另外，相对于xml和json来说，因为被编码成二进制，破解成本增大
            4、语言无关和平台无关：把proto文件转成字节流，可以采用不同的语言，也就是说整个编解码过程完全不依赖某种语言的特性。

            缺点：
            可读性差：因为最终是转成二进制流，不像xml和json能够直接查看明文。
        4、proto3和proto2的区别
            1、在第一行非空白非注释行，必须写：syntax = "proto3";
            2、枚举类型的第一个字段必须为 0。
            3、移除了 default 选项
            4、字段规则移除了 “required”，并把 “optional” 改名为 “singular”；


4、HTTP1.0 、HTTP1.1 和 HTTP2.0区别
  1、HTTP不足
  1、TCP连接数过多
  	1、HTTP1.0 只允许一条tcp连接上处理一个request
  	2、HTTP1.1 支持管道，通过管道，允许浏览器多个请求可以同时发送到服务器，但是服务器的响应只能够一个接着一个的返回，
  		在HTTP1.1 浏览器默认开启keep-alive
  2、HTTP头部过多重复
  	1、HTTP1.X  中，头部有host Connection,origin,Content-type  等一堆头部，都在不同的请求中重复出现
  	除了浪费大量流量，还会导致TCP的初始化拥塞窗口（initcwnd）快速满了，当多个请求准备在同一个tcp连接上发送时，
  	会导致大量的延迟。（当 initcwnd >= ssthresh 时，tcp就会进入“拥塞控制算法”，把发送的速度调慢，避免快速导致网络拥塞，慢慢的增加调整到网络的最佳值）
  3、HTTP1.x 使用的文本协议
  	文本协议虽然具有可读性，方便debug，但是在高性能网络上会有影响传输性能

  2、HTTP2
  	1、兼容HTTP1.X的语义
  	2、允许多个request/response 在同一个tcp连接上发送，实现真正的IO复用
  	3、高效的压缩头部（http header）
  		采用HPACK 处理重复冗余的头部，大致是（客户端发送请求前，在内部创建一个hash表，索引对应着头部和值，并将此对
  		应表发送到服务器，服务器首次接收到以后，也维护一个一摸一样的表，之后有重复头部时，客户端直接发送索引值即可。

  	4、支持server push
  		HTTP2.0 打破了HTTP1 中一问一答的方式，允许服务器往客户端推送数据。（
  		服务器主要通过 PUSH_PROMIS 帧），把预估客户端的可能需要的资源，在其没有请求的前直接发送给对方，让对方缓存。

  	5、有自己的流量控制，保证各个stream 不被互相打扰
  		HTTP2 通过WINDOW_UPDATE帧告诉对方自己准备接收多少字节的数据，注意只有DATA帧才会受到限制，因为其他帧都不大。

  	6、支持请求优先级发送，优先级越高如核心scc,html 优先发送给客户端。
  		客户端在开启一个流的时候，通过设置HEADER帧中的PRIORITY这个flag 来指定流的优先级，这样子就可以
  		做到优先级越高例如：核心css，html 优先发送给客户端。


  3、HTTP2 中的帧和流概念
  	1、帧（frame）
  		HTTP2 中二进制协议的基本单元叫frame(帧)，不同frame有不同的作用，如：
  		1、•SETTING 帧：建立连接时，向对方传达一些配置信息如是否开启 server push 功能、最大帧 size等等（牢记，下文不累述此）；
          2、•HEADERS 帧：发送 http 的 request 或者response的头部；
          3、•CONTINUATION 帧：headers 要跨越多个帧，用此来指示头部上一个 HEADERS；本质就是 HEADERS 帧，但是为了轻松处理，就用明确的类型来区分这种情况；
          4、•DATA 帧：发送body数据用；
          5、•PUSH_PROMISE 帧：用来告知对端初始化哪些数据，就是以上说到的 server push 功能
          6、•WINDOW_UPDATE 帧：用来做流量控制

      2、流(stream)
      	简单说，客户端与服务器端之间相互发送的帧，都通过一个个独立流来传输的，多个流可以在同一个http2连接中并发
      	而每个流都有一个ID（stream Identifier），frame就是通过此来识别流。
      	流你可以理解为一个抽象概念，就是为了区分不同的请求，用于多路复用。



5、之前我自己简单实现过一个rpc的框架：（主要参考网上的博客）
    1、定义服务端和客户端消息的编码，序列化协议。
        1、采用encoding/gob 和 application/json （Gob 是Go语言自己以二进制形式序列化和反序列化程序数据的格式，可以在 encoding 包中找到。这种格式的数据简称为 Gob（即 Go binary 的缩写）
    2、定义服务端和客户端 网络传输的协议及框架。
        1、http协议，及httpClient （以后可以考虑采用netty网络通信框架）
    3、客户端。
        1、获取可用的服务链接。
        2、实现发送请求，接受并处理响应结果。
        3、负载均衡策略用的是 轮询&随机，也可以使用（一致性hash）
     4、服务端
        1、启动服务，通过反射将结构体映射为服务。
     5、实现一个简单的支持心跳保活的注册中心
        1、定时器每隔1s检测服务，从而实现心跳检测。
        2、把服务地址注册到一个map列表中维护。
     6、实现简单的超时的处理机制
        1、客户端超时。使用 context 包中 context.WithTimeout实现，控制权交给用户，控制更为灵活
        2、服务端超时。time.After() 结合 select+chan 完成。（服务端开启子协程处理请求，处理完成后，通过channel通知，并通过time.After监控处理是否超时）

6、HTTP 和 RPC 的区别
    1、两则都是应用调用另一个应用的解决方案
        1、暴露接口  使用http调用。
        2、远程过程调用rpc

    2、传输协议
        RPC，可以基于TCP协议，也可以基于HTTP协议
        HTTP，基于HTTP协议（在TCP协议之上进行封装）

    3、传输效率
        RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率
        HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，
        那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理

    4、性能消耗，主要在于序列化和反序列化的耗时
        RPC，可以基于高效的二进制传输
        HTTP，大部分是通过json来实现的，字节大小和序列化耗时
