分布式缓存总结

1、常用的分布式缓存。
    Redis,Memcache,groupcache.
    常用Redis, Memcache项目中也有用到， 有了解go语言实现的 groupcache。并且根据groupcache，参考网上的例子实现了geecache。主要为了熟悉go项目经验和分布式缓存流程。

2、参考Redis缓存总结

3、Memcache缓存总结。

    1、Memcache是一个高性能的分布式内存对象缓存系统。它把数据存放到内存中，从而通过内存访问提速。
        它在Memcached中维护了一张很大的hash表，该表在内存中，表的结构是key-value.

        key 一般是字符串，且唯一，value可以存放字符串，数值，对象，bool，数组，null等数据。

    2、特点
        1、所有的数据都保存在内存中，存取的数据的比硬盘快，当内存满后，通过LRU算法自动删除不使用的缓存，
        但是没有考虑到容灾问题，重启服务时，所有的数据都会丢失。
        memcache本身就是为缓存而设计的服务器，因此并没有考虑数据的永久性问题。
        2、memcache是基于客户端的分布式。
            memcache尽管是"分布式"缓存服务器，但服务器并没有分布式的功能。各个Memcached服务器之间不通信，
            各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于memcache客户端。



1、Redis 和Memcache 区别
	1、数据类型
		Redis支持的数据类型要丰富得多,Redis不仅仅支持简单的k/v类型的数据，同时还提供String，List,Set,Hash,Sorted Set,pub/sub,Transactions数据结构的存储。其中Set是HashMap实现的，value永远为null而已
memcache支持简单数据类型，需要客户端自己处理复杂对象 k/v

	2、持久性
		redis支持数据落地持久化存储,可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
	memcache不支持数据持久存储


	3、分布式存储
		redis支持master-slave复制模式，redis-cluster模式
		memcache的分布式是基于客户端的，可以使用一致性hash做分布式

	4、内存管理
	1、Memcache 的内存管理机制

			1、内存碎片化
				如果c语言直接向系统malloc，free申请和释放内存时，在不断的申请和释放的过程中，形成了一些很小的内存片段，无法再利用，这种空闲，但无法利用内存的现象，---成为内存的碎片化
			2、slab allocator缓解内存碎片化
				1、Slab allocator原理
				提前把内存分为多个 slab allocator仓库(每个slab allocator大小1M)，各个仓库，切成不同的小块(chunk)
				需要存储内容的时候，判断内容的大小，为其选取合理的仓库
				2、Memcache根据收到的数据大小，选择最适合数据大小的chunk组(slab class)，memcache中保存着slab class内空闲chunk列表，根据该列表选择空的chunk，然后将数据缓存于其中

			3、如果有 100byte 的内容要存,但 122 大小的仓库中的 chunk 满了并不会寻找更大的,如 144 的仓库来存储,而是把 122 	仓库的旧数据踢掉! 详见过期与删除机制

			4、固定大小的trunk带来的问题
				由于在slab allocator分配机制中，分配的trunk的大小是固定的，对于特定的item，很有可能造成内存空间的浪费
				比如100字节的数据缓存到122字节的chunk中，剩余的22字节就浪费

				对于chunk空间浪费的问题，我们无法彻底的解决，只能缓解。但是，目前我们无法指定trunk的大小，只能调节slab class中trunk大小的增长速度，即很重要的一个概念，增长因子 grow factor!
			5、memcache基于每一个slab进行lru回收

      2、过期策略
                memcache 使用Lru(最近最少使用)加上到期失效的策略。
                Lru:   当空间不足的时候，memcache会优先使用已经过期的数据空间，如果还不够，那么就会把最近最少使用的对象的空间释放出来使用。（
                需要注意的是 memcache的lru是作用于slab 块的 ，而不是全局，是一个区域性的lru）
                lazy Expiration（惰性过期）的侧罗：memcache不会监控是否过期，而是在外部来获取数据的时候，才检查记录的时间戳，查看对应的key是否过期，
                这样做的目的，减轻服务器的负载。
一致性hash

1、普通的hash算法在分布式应用中的不足：
	在分布式的存储系统中，要将数据存储到具体的节点上，如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。

2、一致性hash算法是怎么解决这个问题的。
	1、一致性hash算法
	一致性哈希提出了在动态变化的Cache环境中，哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用

	2、1环形hash空间
		按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。
	3、2.2映射服务器节点
		将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置
		假设我们将四台服务器使用ip地址哈希后在环空间的位置如下：
			https://pic4.zhimg.com/80/v2-252cc4ed5bbb07e5e1e3b27c5eda0d23_1440w.jpg
	4、2.3映射数据
		现在我们将objectA、objectB、objectC、objectD四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。
			参考图：https://pic3.zhimg.com/80/v2-0fb33fe30c7a05eee2abe3784a42f98a_1440w.jpg
		2.4服务器的删除与添加
			1、删除。如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化
			2、新增	如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。
				参考图：https://pic4.zhimg.com/80/v2-bf7daae4aa145478dd55fc339ee57ec7_1440w.jpg

		2.5.虚拟节点
			到目前为止一致性hash也可以算做完成了，但是有一个问题还需要解决，那就是平衡性。从下图我们可以看出，当服务器节点比较少的时候，会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。

			为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：


			同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。每个物理节点关联的虚拟节点数量就根据具体的生产环境情况在确定

			参考链接：https://pic1.zhimg.com/80/v2-5d9cdea01cb4b44162aa41980345e8ac_1440w.jpg

