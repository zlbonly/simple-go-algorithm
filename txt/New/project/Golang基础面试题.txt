goland面试题
一、基础语法
1、空 struct{} 的用途
	1、首先 空结构体 不占用空间（使用unsafe.Sizeof输出发现空结构体不占用任何的内存空间）因此，
	空结构体长用来作占位符。使用场景例如
	场景1
		2、不发送数据的信道(channel)
		有时候使用channel不用来发送数据，只用来通知子协程（goroutine）执行任务或者控制并发度，
		这种情况下可以使用空结构体。
		eg：

		func worker(ch chan struct{})
		{
			<-ch
			fmt.println("do something")
			close(ch)
		}

		func main() {
				ch := make(chan struct{})
				go worker(ch)
				ch <- struct{}{}
		}

    2、struct 能不能比较
        1、同一个struct的两个实例能不能比较。
           1、结构体成员中没有不可以比较的成员时，可以直接比较。
           2、结构体成员中有不可以比较的成员时，结构体成员中，有不可以比较的成员时，不能直接比较。但是可以借助reflect.DeepEqual()进行深度比较。
            说明：DeepEqual函数用来判断两个值是否深度一致

        2、两个不同的struct的实例能不能比较。
            两个不同的struct不能比较。
2、 init() 函数是什么时候执行的？
	1、在 Go 语言设计过程中保留了默认的两个函数，分别是 main() 和 init() 函数。
		main() 函数只能使用于 main 包中，而且每个 main 包只能有 一个main() 函数
	但对于 init() 函数, 则能够使用在所有的包中。而且一个程序（甚至一个文件）中可以写任意多个 init() 函数
	1、golang的init函数 会在程序执行开始前调用，每个包可以包含多个init函数，并且在main执行前调用，
	常用来注册一个程序所需要的依赖，如mysql注册，parse配置文件加载等。
	2、注意：一个程序（甚至一个文件）中可以写任意多个 init() 函数，但对于维护代码可读性、排查问题并没有任何好处
	不同包的 init()执行顺序，按照 导入包的依赖关系 决定
	3、golang runtime执行顺序 执行顺序总结： import –> const –> var –> init() –> main()

3、go语言select机制
    1、select系统调用可以同时监听多个文件描述符的可读或者可写状态。Go语言中 select 也能够让 Goroutine 同时等待多个 Channel 可读或者可写，在多个文件或者 Channel状态改变之前，select 会一直阻塞当前线程或者 Goroutine。
        a: select 能在 Channel 上进行非阻塞的收发操作；
        b: select 在遇到多个 Channel 同时响应时，会随机执行一种情况；
        c: 非阻塞的收发 #在通常情况下，select 语句会阻塞当前 Goroutine 并等待多个 Channel 中的一个达到可以收发的状态。但是如果 select 控制结构中包含 default 语句，那么这个 select 语句在执行时会遇到以下两种情况：
        当存在可以收发的 Channel 时，直接处理该 Channel 对应的 case；
        当不存在可以收发的 Channel 时，执行 default 中的语句；
4、 以下代码有什么问题，说明原因。

type Student struct {
	Name string
	Age int
}

func parseStudent()  {
	m := make(map[string]*Student)
	student := []Student{
		{
			Name: "zhou",
			Age: 24,
		}, {
			Name: "li",
			Age: 23,
		}, {
			Name: "wang",
			Age: 22,
		},
	}

	for _,stu := range student{
		m[stu.Name] = &stu
	}
	/*for _,stu := range student{
		temp := stu
		m[stu.Name] = &temp
	}*/
	fmt.Printf("studentli=%+v,wang=%+v,zhou=%+v",m["li"],m["wang"],m["zhou"])
}

golang foreach 都是使用副本的方式。所以m[stu.Name]=&stu实际上一致指向同一个指针，最终该指针的值为遍历的最后一个struct的值拷贝

5、简单介绍下 golang 中 make 和 new 的区别？
	1、new(T)是为一个 T 类型的新值分配空间, 并将此空间初始化为 T 的零值, 并返回这块内存空间的地址, 也就是 T 类型的指针 *T, 该指针指向 T 类型值占用的那块内存.
	2、make(T)返回的是初始化之后的 T (引用类型本身), 且只能用于 slice, map, channel 三种类型. make(T, args) 返回初始化之后 T 类型的值, 且此新值并不是 T 类型的零值, 也不是 T 类型的指针 *T, 而是 T 类型值经过初始化之后的引用.

6、区分闭包函数,defer ，recover ，有名函数，无名函数
1、  闭包函数，又称匿名函数
   1、闭包可能会导致变量逃逸到堆上来延长变量的生命周期，给 GC 带来压力。
   2、  内函数对外函数的变量的修改，是对变量的引用。共享一个在堆上的变量。 变量被引用后，它所在的函数结束，这变量也不会马上被销毁。相当于变相延长了函数的生命周期。
    看个例子：

        func AntherExFunc(n int) func() {
            n++
            return func() {
                fmt.Println(n)
            }
        }

        func ExFunc(n int) func() {
            return func() {
                n++
                fmt.Println(n)
            }
        }

        func main() {
            myAnotherFunc:=AntherExFunc(20)
            fmt.Println(myAnotherFunc)  //0x48e3d0  在这儿已经定义了n=20 ，然后执行++ 操作，所以是21 。
            myAnotherFunc()     //21 后面对闭包的调用，没有对n执行加一操作，所以一直是21
            myAnotherFunc()     //21

            myFunc:=ExFunc(10)
            fmt.Println(myFunc)  //0x48e340   这儿定义了n 为10
            myFunc()       //11  后面对闭包的调用，每次都对n进行加1操作。
            myFunc()       //12

        }
7、return xxx这一条语句并不是一条原子指令
  1、含有defer函数的外层函数，返回的过程是这样的：先给返回值赋值，然后调用defer函数，最后才是返回到更上一级调用函数中
  2、defer函数的参数值，是在申明defer时确定下来的
  3、在defer函数申明时，对外部变量的引用是有两种方式：作为函数参数和作为闭包引用
    作为函数参数，在defer申明时就把值传递给defer，并将值缓存起来，
    调用defer的时候使用缓存的值进行计算（如上边的例3）
    而作为闭包引用，在defer函数执行时根据整个上下文确定当前的值

    func c() (i int) {
        defer func() { i++ }()
        return 1
    }

    Panic
    panic是go的内置函数，它可以终止程序的正常执行流程并发出panic（类似其他语言的exception）。
    比如当函数F调用panic，f的执行将被终止，然后defer的函数正常执行完后返回给调用者。对调用者而言，F的表现就像调用者直接调用了panic。
    这个流程会栈的调用次序不断向上抛出panic，直到返回到goroutine栈顶，此时，程序将会崩溃退出。panic可以通过直接调用panic产生。同时也可能由运行时的错误所产生，例如数组越界访问。

    Recover
    recover是go语言的内置函数，它的主要作用是可以从panic的重新夺回goroutine的控制权。
    Recover必须通过defer来运行。在正常的执行流程中，调用recover将会返回nil且没有什么其他的影响。但是如果当前的goroutine产生了panic，recover将会捕获到panic抛出的信息，同时恢复其正常的执行流程。
    	defer func() {
    		if r := recover(); r != nil {
    			tx.Rollback()
    		}
    	}()

8、golang 使用组合的方式实现继承
     golang并非完全面向对象的程序语言，为了实现面向对象的继承这一神奇的功能，golang允许struct间使用匿名引入的方式实现对象属性方法的组合

     组合使用注意项
     使用匿名引入的方式来组合其他struct
     默认优先调用外层方法
     可以指定匿名struct以调用内层方法

     type People struct{}

     type People2 struct{}

     func (p *People) ShowA() {
         fmt.Println("showA")
         p.ShowB()
     }
     func (p *People) ShowB() {
         fmt.Println("showB")
     }

     func (p *People) ShowC() {
         fmt.Println("showC")
     }

     func (p *People) ShowD() {
         fmt.Println("People:showD")
     }

     func (p *People2) ShowD() {
         fmt.Println("People2:showD")
     }

     type Teacher struct {
         People  //组合People
         People2 //组合People2
     }

     func (t *Teacher) ShowB() {
         fmt.Println("teacher showB")
     }
     func (t *Teacher) ShowC(arg string) {
         fmt.Println(arg)
     }

     func main() {
         t := Teacher{}

         //print showA
         //print showB
         t.ShowA()

         //print teacher showB
         t.ShowB()

         //print showB
         t.People.ShowB()

         //print test
         t.ShowC("test")

         //print showC
         t.People.ShowC()

         //因为组合方法中多次包含ShowD，所以调用时必须显示指定匿名方法
         //print People2:showD
         t.People2.ShowD()
     }


10、golang nil slice 和 empty slic 的区别 空切片

	1、var slice []int 创建出来的 slice 其实是一个 nil slice。它的长度和容量都为0。和nil比较的结果为true。这里比较混淆的是empty slice，empty slice的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 0xc42003bda0。空切片和 nil 比较的结果为false。


	2、空切片的定义：
	var slice = []int{}
	var slice = make([]int,0)

	empty slice 是指slice不为nil，但是slice没有值，slice的底层的空间是空的，此时的定义如下：
	当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值。


	3、var slice []int
	slice[1] = 0
	此时slice的值是nil，这种情况可以用于函数需要返回slice，当函数出现异常的时候，保证函数依然会有返回值nil