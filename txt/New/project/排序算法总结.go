package txt

/**
1、快速排序算法
快速排序算法通过多次比较和交换来实现排序，其排序流程如下：
(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。
(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值
(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理
(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了.

	1、选取中间元素 作为基准值
	2、左边都比中间元素小，
	3、右边都比中间元素 大
	然后递归
	时间复杂度 nlog（n）,空间复杂度log(n),不稳定排序


快排对近乎有序的数组排序会怎么样?和 快排对含⼤大量量重复元素的数组排序会怎么样?怎么优化?
1、默认选择左边第⼀一个元素作为基准数，这就导致⼩小与基准的数会相当少，⽽而⼤大于基准的数相当多，造成分区不不平衡的问题，普 通排序就会退化，严重的将退化成O(n^2)。所以对其改进:不不再默认选择第⼀一个数，⽽而是随机选⼀一个数作为基准，这样的快排称为 随机普通快排。
因此我们⼀一般选择left ~ right 中间
随机某个元素，尽量量避免出现O(n*n)，⼀一般都是选择中间节点。
2、快排中⼤大量量重复元素。也会导致 最坏的时间复杂度 O(n*n),并且排序前后元素的位置发⽣生变化。不不稳定排序。



*/
func quickSort(arr []int, left, right int) {
	if left >= right {
		return
	}
	i, j := left, right
	pivot := arr[(i+j)/2] // 这里的经验值取的是中间数，经过 Benchmark 测试，确实比较优秀
	for i <= j {
		// 从左边开始迭代
		// 左边的数如果比 pivot 小，那么就应该将他放在左边，继续向右滑动，遇到一个比他大的为止
		for arr[i] < pivot {
			i++
		}
		// 右边的数如果比 pivot 大，那么就应该将他放在右边，继续向左滑动，遇到一个比他小的为止
		for arr[j] > pivot {
			j--
		}
		// 这里进行一次交换，将上面碰到的大数和小数交换一次
		//left 继续右走，right 继续左走 注意这里还不一定相遇，去继续执行上面的逻辑
		if i <= j {
			arr[i], arr[j] = arr[j], arr[i]
			i++
			j--
		}
	}
	quickSort(arr, left, j)
	quickSort(arr, i, right)
}

/**
2、堆排序：
	大顶堆：每个结点的值都大于或等于其左右孩子结点的值
	小顶堆：每个结点的值都小于或等于其左右孩子结点的值
	根据对的特性来形成公式就是，节点为i的话
	大顶堆: arr[i]>=arr[2i+1] && arr[i]>=arr[2i+2]
	小顶堆：arr[i]<=arr[2i+1] && arr[i]<=arr[2i+2]
*/

/*
堆排序：
平均时间复杂度nlogn ,最坏的时间复杂度nlogn，不稳定排序
1、堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。
2、完全二叉树：设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，
第 h 层所有的结点都连续集中在最左边。

3、大顶堆和小顶堆
1、大顶堆：每个结点的值都大于或等于其左右孩子结点的值
2、小顶堆：每个结点的值都小于或等于其左右孩子结点的值

3、  升序----使用大顶堆
降序----使用小顶堆
每个结点的值都大于或等于其左右孩子结点的值，我们把大顶堆构建完毕后根节点的值一定是最大的，然后把根节点的和最后一个元素（也可以说最后一个节点）交换位置，那么末尾元素此时就是最大元素了

4、在第一个元素的索引为 0 的情形中：
性质一：索引为i的左孩子的索引是 (2*i+1);
性质二：索引为i的左孩子的索引是 (2*i+2);
最后一个非叶子节点的序号也是n/2-1。

5、堆排序思想
最大堆进行升序排序的基本思想：
① 初始化堆：将数列a[1...n]构造成最大堆。
② 交换数据：将a[1]和a[n]交换，使a[n]是a[1...n]中的最大值；然后将a[1...n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值；然后将a[1...n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。

*/

func HeadSort(nums []int) {
	// 1、从最后一个非叶子节点开始 从下向上构建大顶堆
	for i := len(nums)/2 - 1; i >= 0; i-- {
		initHead(nums, i, len(nums))
	}

	// 2、交换 nums[0] 和 nums[n] 的元素
	// 3、0 ～ n-1 继续构建大顶堆
	for i := len(nums) - 1; i > 0; i-- {
		nums[0], nums[i] = nums[i], nums[0]
		initHead(nums, 0, i-1)
	}
}

func initHead(nums []int, parent, len int) {
	// 1、临时存父节点
	// 2、子节点 2*parent+1
	temp := nums[parent]
	child := 2*parent + 1
	for child < len {
		if child+1 < len && nums[child] < nums[child+1] {
			child++
		}
		if child < len && nums[child] <= temp {
			break
		}
		nums[parent] = nums[child]
		parent = child
		child = child*2 + 1
	}
	nums[parent] = temp
}
