高并发系统三大利器：缓存、降级、限流

缓存：提升系统访问速度和增大处理容量，为相应业务增加缓存。
降级：当服务器压力剧增时，根据业务策略降级，以此释放服务资源保证业务正常。
限流：通过对并发限速，达到拒绝服务、排队、等候、降级等处理


1、缓存 参考分布式缓存总结

2、降级
    1、主动降级
        主动降级，降低非核心服务级别；保证自己的服务不被拖垮。
            （例如:企鹅体育 在cba总决赛期间，直播间内禁止充值，禁止用户修改信息等）
    2、被动降级 （我归结为熔断，一般是下游引起）
       一般指我们自己服务，检测到下游服务的成功率下跌严重时，可以切换为不依赖该下游服务的状态，保证自身主业务的正常运行。
3、服务限流
    限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形。


    1、常用的限流策略包括：
      1、拒绝策略：
         1、超过阈值直接返回错误；
         2、调用方可做熔断降级处理。
      2、延迟处理：
         1、设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现（MQ：削峰填谷）
         2、用异步的方式去减少了后端的处理压力。
      3、特权处理：
         1、这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群的请求就会延迟处理或者直接不处理。

    2、常用的限流算法包括：
        1、计数器
            计数器算法
            这是最容易理解和实现的算法，假设一个接口1s中最多请求100次。最开始设置一个计数器count=0，来一个请求count+1，1s之内count<=100的请求可以正常访问，count>100的请求则被拒绝，1s之后count被重置为0，重新开始计数
            当然这种方式有个弊端，1s内只有最开始的100个请求能正常访问，后面的请求都不能正常访问，即突刺现象。此时我们就可以用滑动窗口算法来解决这个问题，例如把1s分成5个时间段，每个时间段能正常请求20次。
        2、漏斗
               漏桶算法的实现逻辑如下：
                1、首先会有一个容器存放请求，该容器有一个固定大小M，所有请求都会被先存放到该容器中。
                2、该容器会有一个转发逻辑，该转发以每T秒N个请求的速率循环发生。
                3、当容器中请求数已经达到M个时，拒绝所有新的请求。

        3、令牌桶算法(Token Bucket Algorithm)
        算法原理：
            1、接口限制 t 秒内最大访问次数为 n，则每隔 t/n 秒会放一个 token 到桶中；
            2、桶中最多可以存放 b 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 会被丢弃；
            3、接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 就阻塞或者拒绝服务

            注意：
        实现方式和漏斗也比较类似,可以使用一个队列保存令牌,一个定时任务用等速率生成令牌放入队列,访问量进入系统时,从队列获取令牌再进入系统.

    区别：
    1、两者主要区别在于“漏桶算法”能够强行限制数据的传输速率，而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。
    2、在“令牌桶算法”中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，所以它适合于具有突发特性的流量
