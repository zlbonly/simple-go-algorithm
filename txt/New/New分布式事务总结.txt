三、分布式事务

	2.3 分布式事务 基础理论

		2.3.1 事务
		事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。

		2.3.2 分布式事务

			分布式事务是指事务的参与者，支持事务的服务器，资源服务器及事务管理器分别位于不同的分布式系统的不同节点上。
			例如：下单接口会扣减库存，生成订单，支付状态等，不仅仅取决于本地的db操作，而且依赖第三方系统的结果。
			这时候分布式事务就保证这些操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

    CAP理论

 1、CAP理论 Consistency (一致性)，Availability （可用性），Partition Tolerance（分区容错性）

    一致性：分布式系统中所有节点在同一时间的数据完全一致。
    可用性：即服务一直可用，而且是正常响应时间。
    分区容错性：分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间通信失败，此时仍可对外提供服务。

    网络分区：
        分布式系统中，多个节点之间的网络本来是联通的，但是因为某些故障（比如部分节点网络出现了问题）某些节点之间不连通了，
        整个网络就分成了几块区域，这就叫网络分区。

        当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。
        简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。


  2、分布式系统 保证 CP 和 AP ，无法保证 CA
    1、为啥无同时保证 CA 呢？
      举个例子：CAP 不可能同时满足，而分区容错性(P)是对于分布式系统而言是必须的。 若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，
      这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。


      ZooKeeper 保证的是 CP。 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。


 3、BASE 理论思想

    BASE 理论是对CAP中一致性C 和 可用性A权衡的结果，是基于CAP定理逐步演化而来的，具体指，Basically Available（基本可用），Soft-state(软状态)，
    和 Eventually Consistent(最终一致性)。 核心思想是，即使无法做到强一致性，但每个应用可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

     注意：BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。


    1. 基本可用
        基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。
        什么叫允许损失部分可用性呢？

        响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。
        系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。

     2. 软状态
            软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
     3. 最终一致性
        最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

        分布式一致性的 3 种级别：
           强一致性 ：系统写入了什么，读出来的就是什么。
           弱一致性 ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。
           最终一致性 ：弱一致性的升级版。，系统会保证在一定时间内达到数据一致的状态，

           ！！！ 业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。


		2.3.2 分布式事务使用场景：
		1、转账：
			转账是最经典那的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。此时就会出现 2 种异常情况：1. 用户 A 的账户扣款成功，用户 B 账户余额增加失败 2. 用户 A 账户扣款失败，用户 B 账户余额增加成功。对于银行系统来说，以上 2 种情况都是不允许发生，此时就需要分布式事务来保证转账操作的成功。
		2、下单扣库存
			在电商系统中，下单是用户最常见操作。在下单接口中必定会涉及生成订单 id, 扣减库存等操作，对于微服务架构系统，订单 id 与库存服务一般都是独立的服务，此时就需要分布式事务来保证整个下单接口的成功。


		2.3.3 分布式事务解决方案

			1、两段式提交2PC(Two-Phase Commit)
                定义：
                    两段式提交协议目标在于为分布式系统保证数据的一致性。它将分布式事物的提交过程分为两个阶段，1、投票，2、事务提交
                    为了让整个数据库集群能够正常的运行，该协议指定了一个 【协调者】单点，用于协调整个数据库集群各个节点的运行。
                    为了简化描述将数据库集群中的各个节点成为 【参与者】。
                大致流程：
                    1、第一阶段 投票
                        该阶段的主要目的是在于打探数据库集群中的各个参与者能否够正常执行事务，具体步骤如下：
                        1、协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行的结果。
                        2、事务参与者收到请求之后，执行事务但是不提交，并记录事务的日志。
                        3、参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。

                     2、第二阶段 事务提交
                        在经过第一阶段协调者的询盘之后，各个参与者会回复自己事务执行的情况，这时候存在3中可能性。
                        1、所有的参与者都能够正常执行事务
                        2、一个或者多个参与者回复事务执行失败
                        3、协调者等待超时

                        针对 第2.1种情况，协调者将向所有的参与者发出提交事务的通知，具体步骤如：
                            1、协调者向各个参与者发送commit通知，请求提交事务
                            2、参与者收到事务提交通知之后执行commit操作，然后释放占用的资源
                            3、参与者向协调者返回事务commit结果信息
                            如流程图：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/2PC-commit1.png

                        针对 第2.2 和 2.3 协调者均认为参与者无法成功执行事务，为了整个集群数据的一致性，所以要向各个参与者发送事务回滚通知，
                        具体步骤如下：
                            1、协调者向各个参与者发送事务rollback通知，请求回滚事务。
                            2、参与者收到事务回滚通知之后执行rollback操作，然后释放占有的资源。
                            3、参与者向协调者返回事务rollback结果信息。
                            流程信息：
                            如流程图：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/2PC-commit2.png

                两段式提交协议解决的是分布式数据库数据强一致性问题，原理简单，易于实现，但是存在一下缺点：
                1、单点问题
                    协调者在整个两阶段提交过程中扮演着举足轻重的作用，一旦协调者所在服务器宕机，就会影响整个数据库集群的正常执行。
                    比如在第二阶段中，如果协调者因为故障不能正常发送事务提交或者回滚通知，那么参与者将一直处于阻塞状态，真个数据库集群将无法提供服务

                2、同步阻塞
                    两段式提交执行过程中，所有的参与者都需要听从协调者的统一调度，期间处于阻塞状态而不能从事其他从操作，效率低下。

                3、数据不一致性
                    两段提交协议虽然是分布式数据强一致性所设计，但仍然存在者数据不一致性的可能性。比如在第二阶段中，假设协调者发出了事务commit通知，但是因为网络问题该通知仅被
                    一部分参与者所收到并执行了commit操作，其余的参与者因为没有收到一直处于阻塞状态，这时候就产生了数据的不一致性。


                 上述问题可以通过 超时机制 很大程度解决。

            2、三段式提交3PC（Three-Phase Commit）

                定义：
                    针对两段式协议存在的问题，三段式协议通过引入一个 【预询盘】阶段，以及超时策略来减少整个集群的阻塞时间，提升系统性能。
                  相比于 2PC 它在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态。
                    3PC 包含了三个阶段，分别是准备阶段、预提交阶段和提交阶段，对应的英文就是：CanCommit、PreCommit 和 DoCommit。
                    三段式提交的三个阶段分别为：
                        1、【准备阶段】（can_commit）
                        2、【预提交】（pre_commit）
                        3、【事务提交】（do_commit）

                     1、第一阶段 准备阶段
                        该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正执行的事务，
                        这个过程是轻量的，具体步骤如下：
                            1、协调者向各个参与者发送事务询问通知，询问是否可以执行事务操作，并等待回复。
                            2、各个参与者依据自身情况回复一个预估值，如果预估自己能够正常执行事务就返回确定信息，并进入预备状态，否者返回否定信息。
                                各个参与者可以利用这一个阶段统一各自的状态。
                     2、第二阶段 预提交
                            本阶段协调者会根据第一阶段的询盘结果采取相应的操作，询盘结果主要有3种：
                            1、所有的参与者都返回确定的信息
                            2、一个或多个参与者返回否定信息
                            3、协调者等待超时

                         针对2.1 情况，协调者会向所有的参与者发送事务执行请求，具体步骤如下：
                            1、协调者向所有的事务参与者发送事务执行通知，
                            2、参与者收到通知后执行事务但是不提交
                            3、参与者将事务执行情况返回给客户端。

                         在上述步骤中，如果参与者等待超时，则会中断事务。针对第2和第3情况，协调者认为事务无法正常执行，于是向各个参与者发送abort通知
                         ，请求推出预备状态。

                     3、第三阶段： 事务提交
                        如果第二阶段事务未中断，那么本阶段协调者将会根据事务执行的返回结果来决定提交或者回滚事务，分为3中情况。
                           1、所有的参与者都能正常执行事务
                           2、一个或者多个参与者执行事务失败
                           3、协调者等待超时

                        针对3.1种情况，协调者向各个参与者发起事务提交请求，具体步骤如下：
                            1、协调者向所有的参与者发送事务commit通知；
                            2、所有参与者在收到通知之后执行commit操作，并且释放占有的资源，
                            3、参与者向协调者反馈事务提交的结果。

                        针对3.2 和 3.3种情况 协调者认为事务无法成功执行，于是向各个参与者发送事务回滚请求，具体步骤如下：
                            1、协调者向所有参与者发送事务rollback通知
                            2、所有参与者在收到执行rollback操作，并且释放占有资源
                            3、参与者向协调者反馈事务回滚结果。

                         在本阶段中 如果因为协调者或者 网络原因，导致参与者迟迟不能收到来自协调者的commit或rollback请求
                         那么参与者将不会如两阶段提交中那样陷入阻塞，而是在等待超时后继续commit，相对于两阶段提交虽然降低了同步阻塞，
                         但是仍然无法完全避免数据的不一致。

                         说明：两段提交协议中所存在的长时间阻塞状态发送的几率还是很低的，所以虽然三段式协议相对于两段式协议对于
                         数据一致性更保障，但是因为效率问题，两段式提交在实际系统中反而更加受宠。

                               参考连接：【链接】分布式事务：两阶段提交与三阶段提交
                             https://segmentfault.com/a/1190000012534071

			    3、TCC 补偿式提交 （try-confirm-cancel）

                       其核心思想是：针对每个业务，都要注册一个与其对应的确认和补偿（撤销）机制，
					    TCC(Try Confirm Cancel)
                   1、 Try 阶段主要是对业务系统做检测及资源预留
                   2、 Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
                   3、 Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
                    举个例子，假入 Bob 要向 Smith 转账，思路大概是：我们有一个本地方法，里面依次调用
                    1、首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
                    2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
                    3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。

                   缺点：每个业务都需要实现 try,confirm，cancel ，实现难度太大。

            4、本地消息表+MQ(kafka)
               该方法解决分布式事务 属于最终一致性范畴。以支付服务和活动服务（优惠券发放，奖励道具&礼包等发送）为例子，介绍本地消息表方案解决分布式方案。

              大致流程：
                     1、用户在支付完成了支付订单成功后，此时会调用活动rpc服务生成活动相关的数据，并给用户发送相关活动奖励，
                     这里需要明确的是：支付服务处理完订单支付等逻辑后，此时若直接调用活动服务生成相关数据的rpc接口，当并发量大，网络异常出现时，
                     肯定会遇到分布式事务的问题。

                    为了业务解耦合和提高充值接口响应速度，因此可以在引入mq来做异步处理相关活动。即用户完成支付订单后，此时可以将消息投递到mq中，
                    然后由活动服务在去监听mq消息去处理相关逻辑。


                    但是mq不可靠。 如果在支付成功，投递mq时，消息丢失，或者活动服务消费mq时 消息丢失。传统的mq没有实现分布式事务，
                    因此可以【引入本地消息表结合mq的方式来解决分布式事务】。保证消息的可靠性投递。

                   大致流程：
                           1、在支付成功时，支付库插入一条记录来记录支付消息，用户在支付成功的时候，往这条消息表插入一条支付成功的消息记录，状态为 "发送中"
                           支付逻辑和插入消息表的代码包裹在一个事务里面，这里保证了本地事务的强一致性。

                           即支付逻辑和插入消息表的消息 组成了一个强一致性事务，要么同时成功，要么同时失败。
                           2、完成1时，向mq中投递一条支付消息，该条支付消息的内容跟保存在支付库消息表的消息内容一致。

                           3、mq接收到消息时候，活动服务监听该消息，处理活动相关逻辑，下发优惠券，返利券，发放道具等。

                           4、活动服务发放后，在反向mq投递一条消费成功的消息。
                           5、同时支付服务又来监听这个活动服务投递的消息，修改本地消息表的消息状态。

                           6、经过前面五步后，整个业务完成了。


                        此时仍然存在消息投递过程失败的问题。一般会引入一个定时任务，扫描 本地消息表，状态= "发送中"的，然后校验活动服务本地表中是否发送过相关奖励，
                         给用户发送。最终达到数据一致性。（业内常用的方案）。

			5、尽最大努力通知
				尽最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。

				这个方案的大致意思就是：

				系统 A 本地事务执行完之后，发送个消息到 MQ；
				这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；
				要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃


分布式事务参考：小米团队的总结 https://xiaomi-info.github.io/2020/01/02/distributed-transaction/
总结： 分布式锁是解决并发时资源争抢的问题，分布式事务和本地事务是解决流程化提交问题。
