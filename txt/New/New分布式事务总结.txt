三、分布式事务
	2.3 分布式事务 基础理论
		2.3.1 分布式事务
			1、分布式事务是指事务的参与者，支持事务的服务器，资源服务器及事务管理器分别位于不同的分布式系统的不同节点上。
		    2、简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用。
		    3、分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

CAP理论

 1、CAP理论 Consistency (一致性)，Availability （可用性），Partition Tolerance（分区容错性）

    一致性：分布式系统中所有节点在同一时间的数据完全一致。
    可用性：即服务一直可用，而且是正常响应时间。
    分区容错性：分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间通信失败，此时仍可对外提供服务。

    网络分区：
        分布式系统中，多个节点之间的网络本来是联通的，但是因为某些故障（比如部分节点网络出现了问题）某些节点之间不连通了，
        整个网络就分成了几块区域，这就叫网络分区。

        当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。
        简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。


  2、分布式系统 保证 CP 和 AP ，无法保证 CA
    1、为啥无同时保证 CA 呢？
      举个例子：CAP 不可能同时满足，而分区容错性(P)是对于分布式系统而言是必须的。 若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，
      这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。


      ZooKeeper 保证的是 CP。 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。


 3、BASE 理论思想

    BASE 理论是对CAP中一致性C 和 可用性A权衡的结果，是基于CAP定理逐步演化而来的，具体指，Basically Available（基本可用），Soft-state(软状态)，
    和 Eventually Consistent(最终一致性)。 核心思想是，即使无法做到强一致性，但每个应用可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

     注意：BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。


    1. 基本可用
        基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。
        什么叫允许损失部分可用性呢？

        响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。
        系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。

     2. 软状态
            软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
     3. 最终一致性
        最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

        分布式一致性的 3 种级别：
           强一致性 ：系统写入了什么，读出来的就是什么。
           弱一致性 ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。
           最终一致性 ：弱一致性的升级版。，系统会保证在一定时间内达到数据一致的状态，

           ！！！ 业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。


		2.3.2 分布式事务使用场景：
		1、转账：
			转账是最经典那的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。此时就会出现 2 种异常情况：1. 用户 A 的账户扣款成功，用户 B 账户余额增加失败 2. 用户 A 账户扣款失败，用户 B 账户余额增加成功。对于银行系统来说，以上 2 种情况都是不允许发生，此时就需要分布式事务来保证转账操作的成功。
		2、下单扣库存
			在电商系统中，下单是用户最常见操作。在下单接口中必定会涉及生成订单 id, 扣减库存等操作，对于微服务架构系统，订单 id 与库存服务一般都是独立的服务，此时就需要分布式事务来保证整个下单接口的成功。


		2.3.3 分布式事务解决方案
			1、两段式提交2PC(Two-Phase Commit)
                定义：
                    两段式提交协议目标在于为分布式系统保证数据的一致性。它将分布式事物的提交过程分为两个阶段，1、投票，2、事务提交
                    为了让整个数据库集群能够正常的运行，该协议指定了一个 【协调者】单点，用于协调整个数据库集群各个节点的运行。
                    为了简化描述将数据库集群中的各个节点成为 【参与者】。
                大致流程：
                    1、第一阶段 投票
                        该阶段的主要目的是在于打探数据库集群中的各个参与者能否够正常执行事务，具体步骤如下：
                        1、协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行的结果。
                        2、事务参与者收到请求之后，执行事务但是不提交，并记录事务的日志。
                        3、参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。

                     2、第二阶段 事务提交
                        在经过第一阶段协调者的询盘之后，各个参与者会回复自己事务执行的情况，这时候存在3中可能性。
                        1、所有的参与者都能够正常执行事务
                        2、一个或者多个参与者回复事务执行失败
                        3、协调者等待超时

                        针对 第2.1种情况，协调者将向所有的参与者发出提交事务的通知，具体步骤如：
                            1、协调者向各个参与者发送commit通知，请求提交事务
                            2、参与者收到事务提交通知之后执行commit操作，然后释放占用的资源
                            3、参与者向协调者返回事务commit结果信息
                            如流程图：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/2PC-commit1.png

                        针对 第2.2 和 2.3 协调者均认为参与者无法成功执行事务，为了整个集群数据的一致性，所以要向各个参与者发送事务回滚通知，
                        具体步骤如下：
                            1、协调者向各个参与者发送事务rollback通知，请求回滚事务。
                            2、参与者收到事务回滚通知之后执行rollback操作，然后释放占有的资源。
                            3、参与者向协调者返回事务rollback结果信息。
                            流程信息：
                            如流程图：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/2PC-commit2.png

                两段式提交协议解决的是分布式数据库数据强一致性问题，原理简单，易于实现，但是存在一下缺点：
                1、单点问题
                    协调者在整个两阶段提交过程中扮演着举足轻重的作用，一旦协调者所在服务器宕机，就会影响整个数据库集群的正常执行。
                    比如在第二阶段中，如果协调者因为故障不能正常发送事务提交或者回滚通知，那么参与者将一直处于阻塞状态，真个数据库集群将无法提供服务

                2、同步阻塞
                    两段式提交执行过程中，所有的参与者都需要听从协调者的统一调度，期间处于阻塞状态而不能从事其他从操作，效率低下。

                3、数据不一致性
                    两段提交协议虽然是分布式数据强一致性所设计，但仍然存在者数据不一致性的可能性。比如在第二阶段中，假设协调者发出了事务commit通知，但是因为网络问题该通知仅被
                    一部分参与者所收到并执行了commit操作，其余的参与者因为没有收到一直处于阻塞状态，这时候就产生了数据的不一致性。

                 上述问题可以通过 超时机制 很大程度解决。
            2、三段式提交3PC（Three-Phase Commit）
                定义：
                    针对两段式协议存在的问题，三段式协议通过引入一个 【预询盘】阶段，以及超时策略来减少整个集群的阻塞时间，提升系统性能。
                  相比于 2PC 它在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态。
                    3PC 包含了三个阶段，分别是准备阶段、预提交阶段和提交阶段，对应的英文就是：CanCommit、PreCommit 和 DoCommit。
                    三段式提交的三个阶段分别为：
                        1、【准备阶段】（can_commit）
                        2、【预提交】（pre_commit）
                        3、【事务提交】（do_commit）

                     1、第一阶段 准备阶段
                        该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正执行的事务，
                        这个过程是轻量的，具体步骤如下：
                            1、协调者向各个参与者发送事务询问通知，询问是否可以执行事务操作，并等待回复。
                            2、各个参与者依据自身情况回复一个预估值，如果预估自己能够正常执行事务就返回确定信息，并进入预备状态，否者返回否定信息。
                                各个参与者可以利用这一个阶段统一各自的状态。
                     2、第二阶段 预提交
                            本阶段协调者会根据第一阶段的询盘结果采取相应的操作，询盘结果主要有3种：
                            1、所有的参与者都返回确定的信息
                            2、一个或多个参与者返回否定信息
                            3、协调者等待超时

                         针对2.1 情况，协调者会向所有的参与者发送事务执行请求，具体步骤如下：
                            1、协调者向所有的事务参与者发送事务执行通知，
                            2、参与者收到通知后执行事务但是不提交
                            3、参与者将事务执行情况返回给客户端。

                         在上述步骤中，如果参与者等待超时，则会中断事务。针对第2和第3情况，协调者认为事务无法正常执行，于是向各个参与者发送abort通知
                         ，请求推出预备状态。

                     3、第三阶段： 事务提交
                        如果第二阶段事务未中断，那么本阶段协调者将会根据事务执行的返回结果来决定提交或者回滚事务，分为3中情况。
                           1、所有的参与者都能正常执行事务
                           2、一个或者多个参与者执行事务失败
                           3、协调者等待超时

                        针对3.1种情况，协调者向各个参与者发起事务提交请求，具体步骤如下：
                            1、协调者向所有的参与者发送事务commit通知；
                            2、所有参与者在收到通知之后执行commit操作，并且释放占有的资源，
                            3、参与者向协调者反馈事务提交的结果。

                        针对3.2 和 3.3种情况 协调者认为事务无法成功执行，于是向各个参与者发送事务回滚请求，具体步骤如下：
                            1、协调者向所有参与者发送事务rollback通知
                            2、所有参与者在收到执行rollback操作，并且释放占有资源
                            3、参与者向协调者反馈事务回滚结果。

                         1、 3PC 相对于 2PC 做了一定的改进：
                             1、3PC 通过预提交阶段可以减少故障恢复时候的复杂性
                             2、引入了参与者超时机制，相对于两阶段提交虽然降低了同步阻塞，
                             3、并且还是会存在数据不一致问题
                               参考连接：【链接】分布式事务：两阶段提交与三阶段提交
                             https://segmentfault.com/a/1190000012534071

			    3、TCC 补偿式提交 （try-confirm-cancel）

                       其核心思想是：针对每个业务，都要注册一个与其对应的确认和补偿（撤销）机制，
					    TCC(Try Confirm Cancel)
                   1、 Try 阶段主要是对业务系统做检测及资源预留
                   2、 Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
                   3、 Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
                    举个例子，假入 Bob 要向 Smith 转账，思路大概是：我们有一个本地方法，里面依次调用
                    1、首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
                    2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
                    3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。

                   缺点：每个业务都需要实现 try,confirm，cancel ，实现难度太大。

            4、本地消息表+MQ(kafka)
                1、我们服务的分布式事务是基于本地消息表+MQ来实现的。具体原理和流程如下
                   1、生产方 开启一个事务，先执行业务数据库操作，在操作本地消息表，新增一条数据。然后提交事务。解析来通过MQ，
                   向消费方 发送本地消息表的数据。
                   2、本地消息表存放的数据如下。
                        这个表应该包括这些字段： id, biz_id, biz_type, msg, msg_result, msg_desc,atime,try_count。
                        分别表示uuid，业务id，业务类型，消息内容，消息状态（成功或失败），消息描述，创建时间，重试次数，
                        其中biz_id，msg_desc字段是可选的。
                   3、消费方。接收到MQ消息后，新增本地消息表的数据，。开启事务操作执行本地的业务，更改本地消息表的状态。 然后向生产方发送MQ消息，
                    通知生产方，更新本地消息表的状态。
                   4、生产方接收到MQ消息，更新本地消息表的状态。
                2、容错处理。
                    1、我们平台 认为 MQ消息 不应该影响业务数据库和本地消息表的操作，因此没有把MQ放在事务中。
                    2、消息投递不成功时，补偿机制。
                        1、生产方 维护定时任务，获取本地消息表中，状态不是已完成的数据，重新发送MQ，倘若次数超过3此，则通过邮件发送报警，人工介入处理。
                        2、消费方，通过数据库的唯一键，保证消息的幂等性，避免重复消费消息。如果存在已经发送的消息表数据，则直接发送已完成的MQ消息。
                           另外消费方，也通过本地定时任务，获取本地消息表中未处理的数据，重试梳理，如果重试次数超过3此，触发邮件报警。

                   优点：
                        1、实现逻辑简单，开发成本比较低
                    缺点：
                        1）本地消息表与业务耦合在一起。
                        2）本地消息表是基于数据库来做的，而数据库是要读写磁盘IO的，因此在高并发下是有性能瓶颈的
			5、尽最大努力通知
				尽最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。

				这个方案的大致意思就是：

				系统 A 本地事务执行完之后，发送个消息到 MQ；
				这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；
				要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃


分布式事务参考：小米团队的总结 https://xiaomi-info.github.io/2020/01/02/distributed-transaction/
总结： 分布式锁是解决并发时资源争抢的问题，分布式事务和本地事务是解决流程化提交问题。
