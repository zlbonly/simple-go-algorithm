1、进程、线程、协程的区别
	1、进程
		1、进程是资源分配的基本单位，每个进程在创建的时候，都分配一个独立的进程地址空间，该进程地址空间称为虚拟内存空间，虚拟内存空间 对于进程而言 看到的是一整块连续的内存空间，但是落实到操作上则是 一块块内存碎片的的东西。主要为了节约内核空间，房间管理内存。
		2、每个进程独立的内存空间，又分为用户空间和内核空间。
			1、用户空间
			用户空间因CPU的“保护模式”只能访问受限的资源，也就是说用户空间是无法直接操作像内存、网卡和磁盘等硬件，只用于用户程序的运行
			2、内核空间
				内核空间可支持访问CPU所有的指令集（ring0 - ring3）以及所有的内存空间、IO及硬件设备；
				所有进程的内核空间，都映射到同一块物理内存区域，因此所有的进程，都共享内核空间。
			3、系统调用
				用户空间通过系统调用的方式访问内核空间。
				进程运行在用户空间时 处于用户态，通过系统调用运行在内核空间时处于内核态。也就是我们常说的是上下文切换。
		3、进程间通信（IPC）
			 由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。
		4、IPC的方式通常有
		    1、管道:通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道
		    2、消息队列:消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。
		    3、共享内存:mmp
		    4、信号量
		    5、信号:信号是进程间通信机制中唯一的异步通信机制，
		    6、Socket：
		    	要与不同主机的进程间通信，那么就需要 Socket 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。
		5、进程有三个状态:
	        1、等待态：等待某个事件的完成；
	        2、就绪态：等待系统分配处理器以便运行；
	        3、运行态：占有处理器正在运行。
    2、线程
    	1、线程是进程的一个执行单元，一个进程可以包涵多个线程，只有拥有了线程的进程才会被cpu执行，所以一个进程至少拥有一个线程。
    	2、共享进程资源。
    		在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间）
    	3、	因为进程资源共享，所以会产生资源竞争，需要通过锁机制来协同

    3、协程
          协程是一种轻量级的用户态线程，协程的创建和调度完全由用户控制（即，协程相对于操作系统而言来说是透明的，操作系统根本不知道协程的存在。）
          goroutine是goalng 语言实现的协程。golang 通过runtime，系统调用等方面对goroutine调用进行了封装和处理，通过GMP的方式进行调度和管理。

          协程比线程的优点：
            1、轻量。每个goroutine默认占用2kb内存，而线程默认是8M .
            2、协程的调度切换，不需要经过 用户态到内核态的上文切换，减少了CPU资源的浪费。

        2、协程原理重要的两步：
          1、协程的运行：
            1、我们都知道，当线程A切换到线程B的时候，需要将线程A的相关执行进度压入栈，然后将线程B的执行进度入栈，并
            进入B线程的执行序列。协程执行的原理也是类似，只不过协程在应用程序实现这一点。但是，协程不是由操作系统
            进行调度的，而是应用程序没有能力和权限执行cpu的调度。为了解决这个问题。

            2、协程基于线程进行执行。具体是在应用程序内部维护了一组数据结构（队列） 和 n个系统线程，真正执行的
            还是线程，协程执行的代码被扔进一个待执行队列中，由这n个线程从队列中拉出来执行。从而解决协程执行的问题。
            php 的swoole 和 go 的goroutie都是基于这个思想实现的。

          2、协程的调度：
            每个协程有独立的栈，而栈既保留了变量的值，也保留了函数的调用关系，参数和返回值，CPU中的栈寄存器SP指向了当前协程的栈。
            而指令寄存器IP保存着下一条要执行的指令地址。因此从协程A 切换到 协程B 时，首先要把SP，IP寄存器的值为线程A保存下来，
            在从内存中找出协程B上一次切换前保存好的寄存器值，写入CPU的寄存器，这样就完成了协程的切换。

2、Golang的GMP 调度
		goroutine是Go语言提供的一种用户态线程,我们也称之为协程。1个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。
		Goroutine 特点：
			1、轻量、占用资源少。每个goroutine默认占用2kb内存，而线程默认都是8M。
			2、协程的调度切换，不需要经过用户态到内核态的上下文切换，因此减少CPU资源的浪费。

		1、早期的调度模型G-M
			1、早期的调度模型只有，G、M和 全局G队列。M 想要执行、放回 G 都必须访问全局 G 队列，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的。
			2、老调度器的缺点。
				1、创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争
				2、M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了很差的局部性，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。
				3、系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销

		2、GMP调度模型
			在新调度器中，除了 M (thread) 和 G (goroutine)，又引进了 P (Processor)。
			Processor，调度器，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。
			(1) GMP 模型
				1、G
				    1、代表一个goroutine，每个goroutine拥有自己独立的栈存放当前运行的内存及状态。当Goroutine被CPU调度时
                       调服器代码负责把CPU寄存器的值保存在Goroutine对象中，当前Goroutine被调度起来运行时，调度器负责
                       把Goroutine对象保存的寄存器的值恢复到CPU的寄存器。
                     2、Goroutine必须与M绑定，在M中执行.
				2、M
				    1、表示内核线程。线程想运行任务就得获取P，从 P 的本地队列获取 G，P 队列为空时，
				     M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。
				     M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。

                3、P
                    1、代表一个虚拟的Processor处理器，内部维护一个等待运行的Goroutine的本地队列。工作线程M优先使用自己绑定P的本地队列.
                    2、P 的本地队列同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。
                    新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。

				4、全局队列（Global Queue）：
					存放等待运行的 G。在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，
					它可以从全局 G 队列获取 G。

                总结：线程M是运行 goroutine 的实体，调度器P的功能是把可运行的 goroutine 分配到工作线程上。
			参考：链接https://cdn.learnku.com/uploads/images/202003/11/58489/Ugu3C2WSpM.jpeg!large

			2、有关 P 和 M 的个数问题 ，P 和 M 何时会被创建
				1、P 的数量：由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。
				2、M 的数量。go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000.

				M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。

				3、P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。
				4、M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。

			3、调度器的设计策略
				1、复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
					1、当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。
					2、当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。
				2、利用并行
					GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。
				3、抢占调度和协作调度：
				    在Go的1.13版本中实现了协作式的抢占式调度
                    	1、协作式抢占调度的工作机制
                    		1、runtime后台设置了一个检测线程sysmon。sysmon会检测P的状态及运行时间，当运行超过10ms时 ，就会给当前P中执行的G打上标记。把G对应的stackgurad设置为StackPreempt 。
                    		2、G被打上标记，设置为StackPreempt后，在进入函数时 必定出发morestack函数，
                    		3、	morestack 会将 goroutine 的现场保存在当前 goroutine 的 gobuf 中，并将执行栈切换到 g0，然后在 g0 上执行 runtime.newstack，当抢占成功后，当前的 goroutine 会被放在全局队列中：

                    	2、缺点：
                    		当一个goroutine运行了很久，但是它并没有调用另一个函数，则它不会被抢占
                    		go func() {
                    			for {
                    			}
                    		}()

                    		因此使用基于信号的抢占调度解决上述。

                    在Go的1.14版本中实现了基于信号的抢占式调度
                    	工作机制如下
                    	1、M 创建时注册一个 SIGURG 信号的处理函数：sighandler。
                    	2、sysmon 线程检测到执行时间过长的 goroutine 或者GC stw 时，会向相应的 M发送 SIGURG 信号。
                    	3、M收到信号后，内核执行 sighandler 回调 函数，强制 插入 asyncPreempt 异步调度函数，保存执行现场。
                    	4、异步抢占回调函数把goroutine 的状态从 running 改成 runnable；接着调 dropg 将 g 和 m 解绑；然后 将 goroutine 丢到全局队列中
                    		M 则继续寻找其他 goroutine 来运行
                    	5、继续执行schedule()调度函数，被抢占的 goroutine 再次调度过来执行时，会继续原来的执行流。

            4、源码
                GMP源码

                1、Goroutine
                	type g struct {
                		m *m // 系统线程M
                		goid   int64 // goroutine idD
                		locked 	*m  // G被锁定只能在M上运行
                		sched  gobuf // goroutine切换时，用于保存g的上下文
                		stackguard   // 用于确定这个goroutine使用的栈空间信息
                		preempt.     // 抢占标志，需要抢占时会设置为preempt = true
                		。。。。
                	}
                2、M
                type m struct {
                	go  *g  // 带有调度栈的goroutine
                	blocked  // 阻塞状态
                	p    *p  // 关联的P
                	mcache	 *mcache. // 当前m分配的缓存
                	。。。。。
                }

                3、Processor

                type p struct {
                	m  *m. // 关联的系统线程m
                	mcache  *mcache // 分配的内存

                	// runqueue. uint32 // p 中可运行的goroutine 本地队列
                	。。。
                }


			5、Go 调度器调度场景过程全解析
				1、 场景 1
					假设 P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用 go func() 创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。
				2、场景 2
					G1 运行完成后 (函数：goexit)，M 上运行的 goroutine 切换为 G0，G0 负责调度时协程的切换（函数：schedule）。从 P 的本地队列取 G2，从 G0 切换到 G2，并开始运行 G2 (函数：execute)。实现了线程 M1 的复用。

				3、 场景 3
					假设每个 P 的本地队列只能存 4 个 G。G2 要创建了 6 个 G，前 4 个 G（G3, G4, G5，G6）已经加入 p1 的本地队列，p1 本地队列满了。
					看场景4
				4、	场景 4
					G2 在创建 G7 的时候，发现 P1 的本地队列已满，需要执行负载均衡 (把 P1 中本地队列中前一半的 G，还有新创建 G 转移到全局队列)，这些 G 被转移到全局队列时，会被打乱顺序。所以 G3,G4,G7 被转移到全局队列。


				5、场景 5
					G2 创建 G8 时，P1 的本地队列未满，所以 G8 会被加入到 P1 的本地队列。G8 加入到 P1 点本地队列的原因还是因为 P1 此时在与 M1 绑定，而 G2 此时是 M1 在执行。所以 G2 创建的新的 G 会优先放置到自己的 M 绑定的 P 上。
				6、场景 6
					在创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行。
					假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程（没有 G 但为运行状态的线程，不断寻找 G）。
				7、场景7
					M2 尝试从全局队列 (简称 “GQ”) 取一批 G 放到 P2 的本地队列（函数：findrunnable()），至少从全局队列取 1 个 g，但每次不要从全局队列移动太多的 g 到 p 本地队列，给其他 p 留点。这是从全局队列到 P 本地队列的负载均衡。
				8、场景 8
					假设 G2 一直在 M1 上运行，经过 2 轮后，M2 已经把 G7、G4 从全局队列获取到了 P2 的本地队列并完成运行，全局队列和 P2 的本地队列都空了，如场景 8 图的左半部分。

					全局队列已经没有 G，那 m 就要执行 work stealing (偷取)：从其他有 G 的 P 哪里偷取一半 G 过来，放到自己的 P 本地队列。P2 从 P1 的本地队列尾部取一半的 G，本例中一半则只有 1 个 G8，放到 P2 的本地队列并执行。

				9、场景 9
					假设M3,M4 分别投去P1的G5，G6
					G1 本地队列 G5、G6 已经被其他 M 偷走并运行完成，当前 M1 和 M2 分别在运行 G2 和 G8，M3 和 M4 没有 goroutine 可以运行，M3 和 M4 处于自旋状态，它们不断寻找 goroutine。

					为什么要让 m3 和 m4 自旋，自旋本质是在运行，线程在运行却没有执行 G，就变成了浪费 CPU. 为什么不销毁现场，来节约 CPU 资源。因为创建和销毁 CPU 也会浪费时间，我们希望当有新
					goroutine 创建时，立刻能有 M 运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费 CPU，所以系统中最多有 GOMAXPROCS 个自旋的线程
					(当前例子中的 GOMAXPROCS=4，所以一共 4 个 P)，多余的没事做线程会让他们休眠。

				10、场景 10
					假设G8 进行了阻塞系统调用，那么M2和P2就会立即解绑，P2会进行判断，如果P2本地队列有G，全局队列有G，或者有空闲的M，那么P2会唤醒一个M和他绑定，否则P2则会加入到空闲的P列表，等待M来获取可用的p

		总结，Go 调度器很轻量也很简单，足以撑起 goroutine 的调度工作，并且让 Go 具有了原生（强大）并发的能力。Go 调度本质是把大量的 goroutine 分配到少量线程上去执行，并利用多核并行，实现更强大的并发。
        	参考链接；https://learnku.com/articles/41728



