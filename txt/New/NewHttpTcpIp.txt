1、七层网络模型，UDP，TCP/IP，HTTP/HTTPS
    1、OSI七层模型：
        应用层（http/https） -》 表示层（命令的解释/加密/解密） =》
        会话层（会话控制&远程寻址） -》传输层（tpc/udp） -》网络层(ip) -》数据链路层 -》物理层
    2、四层模型
         应用层 -》 传输层（TCP/UDP协议）-》网络层 -》 链路层
    3、TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。
         eg: 比如你需要访问一个网页，浏览器会先生成HTTP的数据包，然后交给传输层去建立连接。
    4、TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。

2、UDP
    1、UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议。
        1、UDP 发送数据前不需要建立连接，
        2、UDP 不可靠，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。
        3、UDP 无序，UDP 有界，UDP 中每一个包都是单独的。
        4、UDP 传输快；UDP 是轻量级的
    2、理论上udp很适合做直播，丢包了一两帧也不会影响用户体验，但是在流量上和及时性上比较好。
     但是目前的直播方案上行都是采用rtmp 或者flv ，底层都是使用tcp.
    3、UDP报文格式：
        每个UDP报文分为：UDP报文头 和 UDP数据区两部分
      	    UDP报文头 包括 ： 源端口（16位） + 目的端口（16位）+ 长度（16位）+校验值（16位）
      	1、源端口：16 位 发送数据报程序使用的UDP 端口
      	2、目的端口：16 位。接收端使用的端口
      	3、长度：16 位。包含UDP报文头和UDP数据长度。因为UDP报文头长度是8字节，因此这个值最小位8。
      	4、校验值：16位，可以校验数据在传输过程中是否被损坏。发短发短发  00:01:59

3、TCP
    1、TCP报文格式。
        TCP是面向面向字节流的、可靠性的传输层协议。
        每个TCP报文也分位：TCP报头和TCP数据
    	TCP报文头包括以下几部分：
    		1、源端口号： 16位
    	    2、目的端口号：16位
    	    3、序号seq: 32位
    	    4、确认序号ack:32位
    	    5、标志位：例如SYN,FIN 12位
    	    6、窗口大小：16位， 用于TCP流量控制。（接收去缓存中大小）

    2、TCP连接（三次握手/四次挥手）
        报文中字段解释：
         1） 序号：seq序号，占32位，用来标识从TCP源端向目地端发送的字节流
         2） 确认号 ack号，占32位，期待收到对方下一个报文段的第一个数据字节的序号。
         3）标识位 （flags）共6哥，即URG,ACK,PSH,RST,SYN,FIN等。具体含义如下
            （A）URG：紧急指针（urgent pointer）有效，值为1时表示某一位需要优先处理。
            （B）ACK：确认序号有效，一般为1。
            （C）PSH：接收方应该尽快将这个报文交给应用层。
            （D）RST：重置连接。
            （E）SYN：请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1。
            （F）FIN：发送断开连接请求。

    2、三次握手

        三次握手 其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的
        接收能力和发送能力是否正常，指定自己的初始化序列号为后面的可靠性传送做准备。

        三次握手过程：

        1、第一次握手：
            客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN，此时客户端处于SYN_SEND状态 （
        首部的同步位SYN=1 ，初始化序号seq=x，SYN=1的报文段不能携带数据，但是要消耗掉一个序号）
        2、第二次握手
            服务器收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化序列号ISN。同时把客户端的ISN+1
            作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_REVD状态。
            在确认报文段中，SYN=1，ACK=1，确认号ack=x+1,初始化序号 seq=y
        3、第三次握手
            客户端收到SYN报文之后，会发送一个ACK报文，把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时
            客户端处于ESTABLISHED 状态。服务器收到ACK报文之后也处于ESTABLISHED状态，此时双方已建立起了连接。

            确认报文段：ACK=1，确认号ack=y+1,序号seq=x+1 (初始为seq=x,第二个报文段所以要+1),ack报文段可以携带数据，
            不携带数据则不消耗序号。

            在socket编程中，客户端执行connect()时，将触发三次握手，并在accept()函数中完成握手连接

            流程图参考：
                https://pic3.zhimg.com/80/v2-2a54823bd63e16674874aa46a67c6c72_1440w.jpg

        3.3、 为什么需要三次握手，两次不行吗？
        第一次握手：客户端发送网络包，服务端收到了。
        这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
        第二次握手：服务端发包，客户端收到了。
        这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力
        是否正常。
        第三次握手：客户端发包，服务端收到了。
        这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
        因此，需要三次握手才能确认双方的接收与发送能力是否正常

        3.4 什么是半连接队列？
            服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。
            当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。
         补充：关于SYN-ACK 重传次数的问题：
            服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

        3.5 三次握手过程中可以携带数据吗？
            其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据
            为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。
            也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED
            状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

        3.4 每次握手失败对应的措施：
            1、如果第一次的SYN传输失败，两端都不会申请资源。如果一段时间后之前的SYN发送成功了，
            这时客户端只会接收他最后发送的SYN的SYN+ACK回应，其他的一概忽略，服务端也是如此，会将之前多申请的资源释放了。
            2、如果服务端发送的SYN+ACK传输失败，客户端由于没有收到这条响应，不会申请资源，
            虽然服务端申请了资源，但是迟迟收不到来自客户端的ACK，也会将该资源释放。
            3、如果第三次握手的ACK传输失败，导致服务端迟迟没有收到ACK，就会释放资源
               1、说明在第二次握手正常，客户端和服务器端接口和发送能力正常。并且客户端已经是established状态，连接建立成功，可以单方面的向服务器TCP发送数据。
               2、第三次握手失败，服务器迟迟没有收到ACK,他的默认状态就是SYN_RCVD。并且根据TCP的超时重传机制，会等待，3，6，12秒重新发送第二组握手的分组，
                 以便客户端重新发送第三次分组。若干次后服务器还没有收到ACK应答，那么服务器将会关闭这个连接。
               3、如果在第三次握手的ACK丢失的情况下客户端向服务端发送了数据，那么服务端将会以（RST包 重置响应）
    4、四次挥手

		建立一个连接需要三次握手，而终止一个连接需要经过四次挥手，这是由于TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另外一端数据的能力。
		TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。
		刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。

		四次挥手的过程如下：

		第一次挥手：
			客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1 状态。
		即发出连接释放报文段（FIN=1，序号seq=u）,并停止在发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待
		服务端的确认。

		第二次挥手：
			服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1 作为ACK报文的序列号值，表明已经收到了客户端的报文了，
			此时服务端处于CLOSE_WAIT状态。

			即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

		第三次挥手：
			如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
			即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

		第四次挥手
			客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

			即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

			说明：
				收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

				在socket编程中，任何一方执行close()操作即可产生挥手操作。
			流程图参考：https://pic2.zhimg.com/80/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg

	4.1 挥手为什么四次
        由于Tcp是连接是全双工的，允许数据在两个方向上同时传输。客户端和服务端的两次挥手，也就是客户端和服务端分别释放连接的过程，
        客户端在最后一次确认之后，还要等待2MSL的时间，主要有两个原因，一个是为了让B能够按照正常步骤进入CLOSED状态。二是为了防止
        已经失效的请求报文出现在下次请求中。 （可以介绍2.2为什么要等待）

	4.2 四次挥手释放连接时，等待2MSL的意义? 和 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？
		说明：MSL可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

		理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。
		所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

		等待2MSL的主要目的总结：
			1、保证客户端发送的最后一个ACK报文段能够到达服务端。
				为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，
				接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

			2、防止“已失效的连接请求报文段”出现在本连接中。
				客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段

4、Tcp 为什么可靠
    1、Ack确认机制 和Seq 保证（消息顺序和可靠性） （可介绍三次握手和四次挥手）
    2、TCP超时重传机制
    	在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据
    3、流量控制
    	参见流程控制总结
    4、拥塞控制
    	参见拥塞控制总结
    5、滑动窗口机制。

5、TCP滑动窗口
    1、作用
    	1、保证TCP传输的可靠性。 主要通过确认机制保证 传输的顺序，以及提高传输的速率。
    	2、进行流量控制。

     2、TCP会话双方都各自维护一个发送窗口和一个接收窗口。
    	1、发送方的发送缓存区内的数据被分为4类。
    	    1、已发送 ，已收到ACK确认 =》 2、已发送，未收到ACK确认 =〉 3、未发送，但是接收端允许发送 =》 4、未发送，接收端不允许发送。

    		2和3 都属于发送窗口

    	2、接收方缓存数据分为3类
    		1、已接收 =》 2、未接收，但是准备接收 ，3=〉 未接收且不准备接收
    					类型2 属于接收窗口。

    	3、滑动机制
    		1、发送窗口只有接收到发送窗口内报文的ACK确认，才会移动发送窗口的左边界。
    		2、接收窗口只有在前面的所有报文段都确认的情况下才会移动左边界。如果前面还有字节未接收，但是接收到后面字节的情况下
    			窗口不会移动，并且不对后续字节确认，以此保证发送方对这些数据进行重传。
    		3、一般来说发送窗口和接收窗口 是一样的。由于网路原因，可能会短暂不相同。

6、流量控制
	1、什么是流量控制
		如果发送者发送数据过快，接受者来不及接收，那么就会出现分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制的根本目的是防止分组丢失，它是TCP可靠性的一方面。

	2、如何实现流量控制
		由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错，有序接收，也实现了流量控制。主要的方式就是接收方返回的ACK中会包含自己的接收窗口的大小，并列利用大小来控制发送方的数据传送。

	3、流量控制引发的死锁？怎么避免死锁的发生。

		1、当发送者接收到了一个rwnd=0(通知窗口)的应答时，发送者便停止发送，等待接收者的下一个应答。但是如果下一个rwnd 不等于0 的应答在传输过程中丢失了，发送者就会一直等待下去，而接收者以为发送者已经收到该应答，也等待接收新的数据，这样双方就互相等待，从而产生思索。
		2、解决死锁。
			为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个rwnd=0的应答时就会启动该计时器。时间一到便主动发送报文询问接收者新的rwnd窗口大小。若接收者仍然返回rwnd=0，则重置计时器继续等待，若rwnd 不等于0，则表示应答报文丢失了，此时重置发送窗口开始发送，这样就避免了死锁。

6、拥塞控制
	拥塞控制时作用于网络的，它主要是防止过多数据注入到网络中，避免出现网络负载过大的情况。
	常用的方法就是：
	  1、慢开始：刚开始建立连接的时候，发送窗口大小为1，然后逐步增加窗口的大小，如每次加倍。
	  	发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。
		慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

	  2、拥塞避免：当发送窗口达到一个门限值之后，窗口大小不再每次加倍，而是每次+1，减缓窗口增大速度。

	  总结 1和2
	  		为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：
	  		1、当cwnd<ssthresh时，使用慢开始算法。
			2、当cwnd>ssthresh时，改用拥塞避免算法。
			3、当cwnd=ssthresh时，慢开始与拥塞避免算法任意

	  3、快重传： 快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期，这是因为此时网络状况良好，可以立即重传。

	  4、快恢复：
	    快速恢复(Fast Recovery)
        （1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
        （2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），
            而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

7、Tcp 粘包和拆包
    由于TCP传输协议面向流的，没有消息保护边界。一方发送的多个报文可能会被合并成一个大的报文进行传输，这就是粘包;也可能发送的一个报文，可能会被拆分成多个小报文，这就是拆包。

    2、TCP粘包原因分析
   1、粘包和拆包
     1、粘包
       粘包问题是指当发送两条消息时，比如发送了 ABC 和 DEF，但另一端接收到的却是 ABCD，像这种一次性读取了两条数据的情况就叫做粘包（正常情况应该是一条一条读取的）。
     2、半包问题是指，当发送的消息是 ABC 时，另一端却接收到的是 AB 和 C 两条信息，像这种情况就叫做半包。

     3、粘包和半包问题？
       这是因为 TCP 是面向连接的传输协议，TCP 传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以 TCP 也没办法判断哪一段流属于一个消息。

       1、粘包的主要原因：
         1、发送方每次写入数据 < 套接字（Socket）缓冲区大小；
         2、接收方读取套接字（Socket）缓冲区数据不够及时。
         3、早起带宽受限，默认开启Negal算法，将多个包合并

       2、半包的主要原因：
         发送方每次写入数据 > 套接字（Socket）缓冲区大小；
         发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包。

    3、解决TCP粘包

        1、Nagel 主要是为了解决带宽，现在的网络带宽提升不少，可以仅用Nagle算法。
        2、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
        3、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
        4、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。
    4、UDP不存在粘包
    由于UDP不是面向‘流’的，而且UDP是具有消息边界的。也就是说UDP的发送的每一个数据包都是独立的。所以UDP并不存在粘包的问题。

8、HTTP 和 HTTPS
    1、什么是HTTPS
        HTTPS是在HTTP上建立SSL/TLS加密层，并对传输数据进行加密，是HTTP协议的安全版。
        TLS 是 SSL的升级版，TLS主要对加密做了增强。
    2、HTTP存在的问题

        1、HTTP通信使用明文（不加密），内容可能被窃听。
        2、HTTP 无法验证报文的完整性，可能遭篡改
            所谓报文的完整性也是指报文信息的准确度。由于HTTP协议无法证明你通信的报文完整性，因此，在请求或响应送出之后直到对方
            接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。
        3、HTTP无法验证通信双方的身份，因此可能遭遇伪装。
            HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。
            另外，服务器只要接收到请求，不管对方是谁都会返回一个响应。因此，HTTP协议无法验证通信双方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，而用户无法擦觉。

    3、HTTPS解决了上述问题
        1、数据隐私性。（内容经过对成加密，每个连接生成一个唯一的加密密钥）
        2、数据完整性。（内容传输经过完整性校验，通过ssl和tsl hash算法进行完整性的校验。相同的数据在hash时会得到相同的值，因此根据这个特性，来验证数据的完整性。）
        3、身份认证。（第三方无法伪造服务端（客户端）身份）

    4、HTTP和HTTPS 层次

        HTTP(传输层协议)					HTTPS（传输层协议）
        TCP                             SSL/TLS
        IP                              TCP
                                        IP

       HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL协议的功能实现主要依赖于三类基本算法。散列函数，对称机密和非对称加密。
       1、利用非对称加密实现身份认证和密钥协商
       2、利用对称加密算法采用协商的密钥对数据进行加密
       3、基于散列函数验证信息的完整性。

       参考结构图：
       https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/TLS:SSL%E6%B5%81%E7%A8%8B%E5%9B%BE.png

    5、HTTPS解决内容可能被窃听的问题 - 加密
        HTTPS 使用对称加密+ 非对称加密 两者并用的混合加密机制
        具体做法： 发送密文的一方使用对方的公钥进行加密处理 ”对称的密钥“，然后对方用自己的私钥解密拿到”对称的密钥“，这样可以确保
        交换的密钥是安全的前提下，使用对称加密方式进行通信。

    6、解决报文可能遭篡改问题 - 数字签名
        HTTPS使用 数字签名，解决报文可能被篡改。
        具体流程：
            1、发送者将一段报文先用HASH 函数生成消息摘要，然后用发送着的私钥加密生成数字签名。并且将数字签名与原报文一起发送给接收者。
            2、接送着用发送者的公钥解密被加密的摘要信息，然后用HASH函数对接收到的原文生成一个摘要信息，并与上一步接收到的摘要信息进行对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。

    7、解决通信方身份可能被伪装的问题 —— 数字证书
        HTTPS使用 数字证书 解决通信方身份可能被伪装的问题
        数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上

        我们来介绍一下数字证书认证机构的业务流程：

        1、服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;

        2、CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;

        3、如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;

        4、客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;

        5、客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。

        6、客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法


    8、HTTPS工作流程

        参考流程图：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/https%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg
        1.Client发起一个HTTPS（比如 https://juejin.im/user）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。

        2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。

        3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。

        4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。

        5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。

        6.Server使用对称密钥加密“明文内容A”，发送给Client。

        7.Client使用对称密钥解密响应的密文，得到“明文内容A”。

        8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。


     9、补充知识 对称加密和非对称加密
        非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。
        非对称加密效率低。

9、HTTP请求报文和HTTP响应报文。
        HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。
        HTTP有两类报文：请求报文和响应报文。
        1、一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，
            1、请求行（request line）
                 请求方法，URL(包括参数信息)，协议版本这些信息（GET /admin_ui/rdx/core/images/close.png HTTP/1.1）
            2、请求头部(Header)是一个个的key-value值，
                HTTP 常见 Header
                Content-Type：数据类型（text/html 等）
                Content-Length：Body 长度
                Host：客户端告知服务器，所请求的资源在哪个主机的端口上；
                User-Agent：声明用户的操作系统和浏览器版本信息
                referer：当前页面是从哪个页面跳转过来的
                location：搭配 3XX 状态码使用，告诉客户端接下来要去访问哪里
                Cookie：用于在客户端存储少量信息，通常用于实现会话 session 的功能
            3、空行
                最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。
            4、请求数据
                请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。
                与请求数据相关的最常使用的请求头是Content-Type和Content-Length。

        2、响应报文
            响应报文 包括四部分： 状态行，消息报头，空行，响应体
              1、状态行也由三部分组成：服务器HTTP协议版本，响应状态码，状态码的文本描述
                    13、状态码
                        1xx     接收的请求正在处理
                        2xx     请求正常处理完毕
                        3xx     重定向
                        4xx     客户端错误
                        5xx     服务端错误

                        100  服务器收到了请求，客户端继续发送
                        200  请求成功
                        301  永久重定向，
                        302  临时重定向
                        401  当前请求需要用户验证
                        403  服务器已经得到请求，但是拒绝执行
                        404  资源不存在
                        405  客户端请求中的方法被禁止
                        414  请求的url过长
                        500  服务器内部错误
                        503  由于超载或者系统维护，服务器暂时没有办法处理客户端的请求


10、浏览器输入URL 返回页面的全过程 （分别介绍八大步骤）

	1.根据域名，进行DNS域名解析；
	2.拿到解析的IP地址，建立TCP连接；
	3.向IP地址，发送HTTP请求；
	4.服务器处理请求；
	5.返回响应结果；
	6.关闭TCP连接；
	7.浏览器解析HTML；
	8.浏览器布局渲染；

        场景：用户在浏览器输入网址：http://live.qq.com，其解析过程如下

        1、DNS域名解析
            先介绍域名结构
                1、http://live.qq.com 实际的域名是 http://live.qq.com.
                根域名(.) => 顶级域名(.com 或者.net) => 次级域名.qq => live(三级域名或者主机名，用户可以自行注册的)

            1、浏览器将会检查缓存中有没有这个域名对应的解析过的IP地址，如果有该解析过程
            将会结束
            2、如果用户的浏览器中缓存中没有，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射关系，完成域名解析。
            3、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系或缓存信息，如果有，直接返回给浏览器，完成域名解析。
            4、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，则会首先找本地DNS服务器，一般是公司内部的DNS服务器，此服务器收到查询，如果此本地DNS服务器查询到相对应的IP地址映射或者缓存信息，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
            5、若没有，则操作系统将域名发送至 本地域名服务器- -（递归查询方式），本地域名服务器 查询自己的DNS缓存，查找成功则返回结果，否则，（以下是迭代查询方式）

                5.1 本地域名服务器 向根域名服务器（其虽然没有每个域名的具体信息，但存储了负责每个域，如com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，根域名服务器返回com域的顶级域名服务器的地址

                5.2 本地域名服务器 向com域的顶级域名服务器发起请求，返回baidu.com权限域名服务器（权限域名服务器，用来保存该区中的所有主机域名到IP地址的映射）地址

                5.3 本地域名服务器 向baidu.com权限域名服务器发起请求，得到www.baidu.com的IP地址

            6、本地域名服务器 将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来

            7、操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来

            至此，浏览器已经得到了域名对应的IP地址。

        2、拿到解析的IP地址，建立TCP连接；（叙述三次握手流程）

        3、向IP地址，发送HTTP请求；
                浏览器会对请求进行包装，包装成请求报文.使用Get/Post等请求方式进行请求。

        4、服务器收到请求并响应HTTP请求
            此步骤一般nginx 会做 反向代理和 负载均衡

            1、正向代理 和 反向代理
                1、正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。

                demo: vpn 就是一种正向代理。VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机
                2、反向代理
                    1、反向代理和正向代理的区别就是：正向代理代理客户端，反向代理代理服务器。
                    2、反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。

            2、负载均衡
                nginx 一般使用轮询 和权重  将请求分配到不同的服务器上。

            3、浏览器请求报文到达服务器之后，服务器接口会对请求报文进行处理，执行接口对应的代码，处理完成后响应客户端。
        5、服务器返回结果

            需要关注一个报文头--accept。accept代表发送端（客户端）希望接受的数据类型，这是浏览器自动封装的请求头。如果服务器返回的content-type是accept中的任何一个，浏览器都能解析，并直接展示在网页上。

            顺道介绍一下状态码： 1xx,2xx,3xx,4xx,5xx。

        6、关闭TCP连接（叙述四次握手）

        7.浏览器解析HTML 和 8.浏览器布局渲染；
            浏览器会根据相应的content-type字段对响应字符串进行解析。能够解析并成功解析就显示，能够解析但解析错误就报错，不能解析就下载


9、HTTP请求报文和HTTP响应报文。
    HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。
    HTTP有两类报文：请求报文和响应报文。
    1、一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，
        1、请求行（request line）
             请求方法，URL(包括参数信息)，协议版本这些信息（GET /admin_ui/rdx/core/images/close.png HTTP/1.1）
        2、请求头部(Header)是一个个的key-value值，
            HTTP 常见 Header
            Content-Type：数据类型（text/html 等）
            Content-Length：Body 长度
            Host：客户端告知服务器，所请求的资源在哪个主机的端口上；
            User-Agent：声明用户的操作系统和浏览器版本信息
            referer：当前页面是从哪个页面跳转过来的
            location：搭配 3XX 状态码使用，告诉客户端接下来要去访问哪里
            Cookie：用于在客户端存储少量信息，通常用于实现会话 session 的功能
        3、空行
            最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。
        4、请求数据
            请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。
            与请求数据相关的最常使用的请求头是Content-Type和Content-Length。


11、http和TCP的区别
    http协议是应用层协议，主要是解决如何包装数据。
    而tcp协议是传输层协议，主要解决数据如何在网络中传输。
    通俗点说，http的任务是与服务器交换信息，它不管怎么连到服务器和保证数据正确的事情。
    而tcp的任务是保证连接的可靠，它只管连接，它不管连接后要传什么数据。
    http协议一定要建在TCP的连接上的。

12、 结合项目说说项目中出现大量close_wait和time_wait。
    close_wait： 被动关闭的一方 会出现close_wait.
            主动关闭的一方发出FIN包，被动关闭的一方响应ACK包，此时，这个时候被动关闭的一方就进入了CLOSE_WAIT状态
            如果一切正常，稍后被动关闭的一方也会发出FIN包，然后进入LAST_ACK状态。
    time_wait: 主动关闭的一方 会出现time_wait

    	1、close_wait 过多的原因。
    		1、挥手的第2阶段，被动关闭的一方进入close_wait后，没有在主动关闭socket导致。
    	2、大量close_wait造成的影响。
    		大量的close_wait的时候会占用服务的fd，而一个服务器能打开的fd数量是有限的，当超过限制时，没有办法在分配fd，因此无法再建立链接。会出现
    		Too Many files 错误。

    	3、如何解决
    		1、可以临时修改进程的最大fd 。通过ulimit -n 65535
    		2、重启打开链接的进程
    		3、排查程序，根据tcpdump和火焰图分析 可能出现没有close的代码位置，及时修复代码bug。

    	4、可能用到的命令：
    		1、查看进程允许打开的最大fd数量. ulimit -n
    		2、产看close_wait的状态的数量
    			netstat -antlp | grep 'CLOSE_WAIT'|wc -l
    		3、查看time_wait的状态数量
    			netstat - antlp| grep 'TIME_WAIT'|wc  - l

     		2、time_wait
    		1、上述大量的 TIME_WAIT 状态 TCP 连接，有什么业务上的影响吗？
    			1、主动关闭的一方会出现time_wait状态，每一个 time_wait 状态，都会占用一个「本地端口」，上限为 65535(16 bit，2 Byte)；
    			2、当大量的连接处于 time_wait 时，新建立 TCP 连接会出错，address already in use : connect 异常

    		2、大量的 TIME_WAIT 状态 TCP 连接存在，其本质原因是什么？
    				1、大量的短连接存在
    				2、特别是 HTTP 请求中，如果 connection 头部取值被设置为 close 时，基本都由「服务端」发起主动关闭连接而，
    				3、TCP 四次挥手关闭连接机制中，为了保证 ACK 重发和丢弃延迟数据，设置 time_wait 为 2 倍的 MSL（报文最大存活时间）
    		3、解决办法
    			1、客户端，HTTP 请求的头部，connection 设置为 keep-alive，保持存活一段时间：现在的浏览器，一般都这么进行了
    			2、服务器端
    				 1、允许 time_wait 状态的 socket 被重用
                     2、缩减 time_wait 时间，设置为 1 MSL(即，2 mins)
                     3、2、不使用短连接，使用长连接，例如使用连接池 。 例如redis 中使用pconnect(长连接，使用后连接不是释放) 是不是使用connect


    项目中实际场景：
    1、项目一问题场景，项目的“抽奖服务”场景  一次Mysql主动关闭，导致服务出现了大量的close_wait

        之前碰到线上一个socket资源不断被打满的情况。服务出现504

        抽奖服务底层是使用Golang开发的，线上已经接近一年，提供给PHP调用，主要的底层资源是DB/Redis/MQ

            服务的架构大致是
            负载均衡器 -》 server1 和server2 => DB 负载均衡器 =〉 db1 和db2

       1、刚开始以为是可能是服务长时间没有重启，内心的一些问题导致了 内存泄漏，没多想找运维进行了重启
        但是没有解决问题，有抽奖活动时，还是出现了问题，意识到不是重启能解决的。
       2、socket资源被打满，之前从来没有出现过，今天突然出现，怀疑是不是请求量最太大压垮服务器了，查看过qps以后，
       发现量虽然增加，但是在服务承受范围内，排除服务器压垮的猜想
       3、两台机器同时出现了故障，重启一台，另一台也会得到缓解，初步推断出时底层依赖的资源出现了问题。

                1、通过 netstat -na | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'查看各个连接状态及数量发现大部分连接处于close_wait状态。

                2、 然后通过netstat -an 命令检查连接端口的详情。发现了3306 mysql端口出现了大量的close_wait

                3、使用tcpdump 进行抓包分析3306端口的包请求过程
                发现，关闭连接只有两条数据：
                    1、mysql给服务发送了FIN 包，服务器也响应了，但是被动关闭的抽奖服务，没有继续FIN，导致一直处于CLOSE_WAIT 状态。

                4、由于代码之前不是我维护的，也是刚接手golang服务，业务逻辑都不是很清楚，因此谨慎 使用perf
                生成了火焰图，把所有的火焰图绘制出现了。
                分析火焰图 发现存在请求时间长的sql,以及没有commit 和 rollback 的事务。


                5、找到代码发现 在事务里面 有个 判断 data == nil  后直接return 了，没有对事务进行rollback;
                    顺手优化了下请求时间长的sql

            总结：由于那一行代码没有对事务进行回滚，导致服务端没有主动发起close。因此 MySQL负载均衡器 在达到 60s 的时候主动触发了close操作，但是通过tcp抓包发现，服务端并没有进行回应，这是因为代码中的事务没有处理，因此从而导致大量的端口、连接资源被占用

      分析close_wait流程：
        1、close_wait 大部分都是由服务器端代码造成的，可以先通过netstat命令分析tcp各个连接的状态，然后使用tcpdump抓包分析，
        然后perf获取火焰图，定位到具体的业务场景及代码，去解决问题。

        5、netstat
            1、列出所有端口 (包括监听和未监听的)
                netstat -a     #列出所有端口
                netstat -at    #列出所有tcp端口
                netstat -au    #列出所有udp端口

            三、netstat常见参数
            -a (all) 显示所有选项，默认不显示LISTEN相关。
            -t (tcp) 仅显示tcp相关选项。
            -u (udp) 仅显示udp相关选项。
            -n 拒绝显示别名，能显示数字的全部转化成数字。
            -l 仅列出有在 Listen (监听) 的服务状态。

            -p 显示建立相关链接的程序名
            -r 显示路由信息，路由表
            -e 显示扩展信息，例如uid等
            -s 按各个协议进行统计
            -c 每隔一个固定时间，执行该netstat命令。
            16、直接统计tcp数量监听的数量
                #netstat -ant | wc -l
            1、应用在高并发运行情况下出现大量TimeWait连接请求
            # 统计命令：
              # 统计已连接上的，状态为“established
              netstat -na|grep ESTABLISHED|wc -l
              # 查看80端口连接数
              netstat -ant|grep -i "80"|wc -l
              # 如果需要统计tcp连接每种状态的连接的数量
              netstat -an | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'