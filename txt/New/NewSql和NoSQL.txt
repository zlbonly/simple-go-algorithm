OLAP:
一、ClickHouse:
  场景特点：
    1、读大于写。
        在OLAP场景中，通常存在一张或是几张多列的大宽表，列数高达数百甚至数千列。对数据分析处理时，选择其中的少数几列作为维度列、其他少数几列作为指标列，
           然后对全表或某一个较大范围内的数据做聚合计算。这个过程会扫描大量的行数据，但是只用到了其中的少数列。而聚合计算的结果集相比于动辄数十亿的原始数据，也明显小得多。
    2、存储特点。
       1、 行存将每一行的数据连续存储不同，列存将每一列的数据连续存储。极大的减低了IO cost，加速了查询
       2、  同一列中的数据属于同一类型，压缩效果显著。列存往往有着高达十倍甚至更高的压缩比，
        节省了大量的存储空间，降低了存储成本。
       3、通过simd指令，在CPU寄存器层面 实现一条指令对数据并行的操作。
       4、比msyql快800倍。


二、MongoDB
    1、mongodb 是一个基于分布式的NoSQL 文档存储数据库。
    2、特点和使用场景。
    	1、模式自由 :可以把不同结构的文档存储在同一个数据库里
    	2、面向集合的存储：适合存储 JSON风格文件的形式，
    	3、复制和高可用性：支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制。复制的主要目的是提供冗余及自动故障转移。
    	4、自动分片：支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器。

    3、适用场景
    	1、网站数据：适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。读远大于写的场景。
    	2、用于对象及JSON数据的存储：MongoDB的BSON数据格式非常适合文档格式化的存储及查询。
    	3、大尺寸、低价值的数据：。例如日志。

    4、MongoDB内存使用原理
    	1、MongoDB使用的是内存映射存储引擎，它会把磁盘IO操作转换成内存操作，如果是读操作，内存中的数据起到缓存的作用，如果是写操作，内存还可以把随机的写操作转换成顺序的写操作，总之可以大幅度提升性能。
    	2、mongodb先把数据写入内存，每隔一定间隔，把数据flush到磁盘中。

    5、mongo 高可用方案。
    	1、Replica set：复制集。
    		复制集，mongodb的架构方式之一 ，通常是三个对等的节点构成一个“复制集”集群，有“primary”和secondary等多中角色（稍后详细介绍），其中primary
    			负责读写请求，secondary可以负责读请求，这有配置决定，其中secondary紧跟primary并应用write操作；如果primay失效，则集群进行“多数派”选举，选举出新的primary，
    			即failover机制，即HA架构。复制集解决了单点故障问题，也是mongodb垂直扩展的最小部署单位，当然sharding cluster中每个shard节点也可以使用Replica set提高数据可用性。
    	2、Sharding cluster：分片集群

    		1、当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据
    		2、分片集群，数据水平扩展的手段之一；replica set这种架构的缺点就是“集群数据容量”受限于单个节点的磁盘大小，如果数据量不断增加，对它进行扩容将时
    			非常苦难的事情，所以我们需要采用Sharding模式来解决这个问题。将整个collection的数据将根据sharding key被sharding到多个mongod节点上，即每个节点持有collection的
    			一部分数据，这个集群持有全部数据，原则上sharding可以支撑数TB的数据。
    		3、分片组件。
    			上图中主要有如下所述三个主要组件：
    			1、Shard:用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组或者一个relica set承担，防止主机单点故障
    			2、Config Server: 路由表服务。每一台都具有全部chunk的路由信息。

    			3、Query Routers: 前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用

    6、mongo 持久化。
    	1、journal日志为mongodb提供了数据保障能力，它本质上与mysql binlog没有太大区别，用于当mongodb异常crash后，重启时进行数据恢复.
    	2、对于write操作而言，首先写入journal日志，然后将数据在内存中修改（mmap），此后后台线程间歇性的将内存中变更的数据flush到底层的data files中，
    	    时间间隔为60秒（参见配置项“syncPeriodSecs”）；write操作在journal文件中是有序的，
    	    为了提升性能，write将会首先写入journal日志的内存buffer中，当buffer数据达到100M或者每隔100毫秒，buffer中的数据将会flush到磁盘中的journal文件中

    7、mongo典型的场景。LBS场景，实现附近的人。
    	1、设计实录
    		MongoDB实现附近的人，主要是通过它的两种地理空间索引 2dsphere 和 2d。 两种索引的底层依然是基于Geohash来进行构建的。
    		1、2dsphere 索引仅支持球形表面的几何形状查询。
    		2、2d 索引支持平面几何形状和一些球形查询。虽然2d 索引支持某些球形查询，但 2d 索引对这些球形查询时，可能会出错。所以球形查询尽量选择 2dsphere索引

    		3、具体查询借助geohear命令api
    			db.hotel.aggregate({
    			    $geoNear:{
    			        near: [115.999567,28.681813], // 当前坐标
    			        spherical: true, // 计算球面距离
    			        distanceMultiplier: 6378137, // 地球半径,单位是米,那么的除的记录也是米
    			        maxDistance: 2000/6378137, // 过滤条件2000米内，需要弧度
    			        distanceField: "distance" // 距离字段别名
    			    }
    			})
    			看到结果中有符合条件的数据，还多出一个字段distance 刚才设置的别名，代表两点间的距离。
