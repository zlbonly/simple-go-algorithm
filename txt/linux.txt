
Linux 基础 知识 准备

Linux 基础知识

	1、Linux架构层级
		Application -》 Shell 和 公共函数库 -〉系统调用 -》 内核

		Apllication: 在操作系统上安装并运行的用户态层序
		Shell : 支持编程的命令解析器
		Libs: 操作系统表标准库函数
		System Calls：暴露给用户的内核态系统调用接口
		Kernel: 操作系统的核心，真正对接硬件平台的软件程序

	操作系统将虚拟内存划分为两部分，一部分是内核空间（Kernel-space）,一部分是用户空间（User-space）。在Linux系统中
	内核模块运行在内核空间，对应的进程处于内核态，而用户程序运行在用户空间，对应的进程处于用户态。

Linux零拷贝技术

   1、为什么需要零拷贝。
          传统的 Linux 系统的标准 I/O 接口（read、write）是基于数据拷贝的，也就是数据都是 copy_to_user 或者 copy_from_user，
          这样做的好处是， 通过中间缓存的机制，减少磁盘 I/O 的操作，但是坏处也很明显，大量数据的拷贝，用户态和内核态的频繁切换，
          会消耗大量的 CPU 资源，严重影响数据传输的性能，有数据表明，在Linux内核协议栈中，
          这个拷贝的耗时甚至占到了数据包整个处理流程的57.1%。

          linux 原始数据拷贝。例如：某个应用程序需要从磁盘读取某个内容，然后通过网络发送出去，

          while((n = read(diskfd, buf, BUF_SIZE)) > 0)
              write(sockfd, buf , n);

              大致经过的流程：
              1、read()将数据从磁盘文件，通过DMA（Direct Memory Access 直接内存读取）等方式拷贝到内核开辟的缓冲区。
              2、数据从内核缓冲区复制到 用户缓冲区
              3、write() 将数据从用户态缓冲区复制到内核协议栈开辟的socket缓冲区
              4、数据从socket缓冲通过DMA拷贝到网卡发送出去。


   2、 什么是零拷贝
            零拷贝是解决1问题的一种解决方案，通过尽量避免拷贝操作来缓解CPU压力。
            Linux 下常见的零拷贝技术可以分为两大类：一是针对特定场景，去掉不必要的拷贝；二是去优化整个拷贝的过程。
            由此看来，零拷贝并没有真正做到“0”拷贝，它更多是一种思想，很多的零拷贝技术都是基于这个思想去做的优化。


        2.1 特定场景的零拷贝

            2.1.1 用户态直接I/O
                使应用程序或者运行在用户态下的库函数直接访问硬件设备，数据直接跨过内核进行传输，内核在整个数据传输过程中除了会进行必要的虚拟
                存储配置工作外，不参与其他任何工作，这种方式直接绕过内核，极大提高性能
                （参考图片）https://pic3.zhimg.com/80/v2-2863a48a73b6438cf96996b7ed992d72_1440w.jpg

                缺陷：
                1、这种方法只能适用于那些不需要内核缓冲区处理的应用程序，这些应用程序通常在进程
                这些应用程序通常在进程地址空间有自己的数据缓存机制，称为自缓存应用程序，如数据库系统就是一个代表
                2、这些方法直接操作磁盘I/O，由于CPU和磁盘I/O 之间的执行时间差距，会造成资源的浪费，解决这个问题需要和异步I/O结合使用

            2.1.2 mmap (内存映射)
                使用mmap 内存映射来代替 read,可以减少一次拷贝操作，流程如下：
                buf = mmap(diskfd,len);write(sockfd,buf,len)；
                应用程序调用mmap,磁盘文件的数据通过DMA拷贝到内核缓冲区，
                接着操作系统会将这个缓冲区与应用程序共享，这样就不用往用户空间拷贝。应用程序调用write，操作系统直接将数据从内核缓冲区拷贝到socket缓冲区，
                最后在通过DMA拷贝到网卡发送出去。相当于只进行了3次拷贝。
                流程参考图：https://pic1.zhimg.com/80/v2-682495ea64eda8eaea168fc125539d14_1440w.jpg

                缺陷：
               1）mmap 隐藏着一个陷阱，当 mmap 一个文件时，如果这个文件被另一个进程所截获，
                    那么 write 系统调用会因为访问非法地址被 SIGBUS 信号终止，SIGBUS 默认会杀死进程并产生一个 coredump，
                    如果服务器被这样终止了，那损失就可能不小了。

                解决这个问题通常使用文件的租借锁：首先为文件申请一个租借锁，当其他进程想要截断这个文件时，内核会发送一个实时的 RT_SIGNAL_LEASE 信号，告诉当前进程有进程在试图破坏文件，
                这样 write 在被 SIGBUS 杀死之前，会被中断，返回已经写入的字节数，并设置 errno 为 success。
                通常的做法是在 mmap 之前加锁，操作完之后解锁：

            2.1.3 sendfile
                从Linux 2.1版内核开始，Linux引入了sendfile，也能减少一次拷贝。
                eg: #include<sys/sendfile.h>ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);

                sendfile系统调用在两个文件描述符之间直接传递数据(完全在内核中操作)，
               从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝。

               流程；
               1、sendfile() 系统调用利用 DMA 引擎将文件中的数据拷贝到操作系统内核缓冲区中，
               2、 然后数据被拷贝到与 socket 相关的内核缓冲区中去。
               3、DMA 引擎将数据从内核 socket 缓冲区中拷贝到协议引擎中去

              缺陷：
                    sendfile() 系统调用不需要将数据拷贝或者映射到应用程序地址空间中去，
                    所以 sendfile() 只是适用于应用程序地址空间不需要对所访问数据进行处理的情况。

               优点： sendfile 传输的数据没有越过用户应用程序 / 操作系统内核的边界线，所以 sendfile () 也极大地减少了存储管理的开销


            2.1.4 DMA 辅助的sendfile
                常规 sendfile 还有一次内核态的拷贝操作。可以使用DMA辅助的sendfile 去掉内核态内的拷贝，流程如下：
                1、首先，sendfile() 系统调用利用 DMA 引擎将文件内容拷贝到内核缓冲区去；
                2、将带有文件位置和长度信息的缓冲区描述符添加到 socket 缓冲区中去，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，
                3、DMA 引擎会将数据直接从内核缓冲区拷贝到协议引擎中去，这样就避免了最后一次数据拷贝。

                流程参考图如下：
                    https://pic4.zhimg.com/v2-63a6315bcda173d1a89f649ee0939f17_r.jpg

                    缺陷：只适用于将数据从文件拷贝到套接字上 及2.1.3中的缺陷

            2.1.5 splice
                splice 去掉 sendfile 的使用范围限制，可以用于任意两个文件描述符中传输数据。
                #define _GNU_SOURCE /* See feature_test_macros(7) */#include <fcntl.h>ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);
                但是 splice 也有局限，它使用了 Linux 的管道缓冲机制，所以，它的两个文件描述符参数中至少有一个必须是管道设备。
                缺陷：

                1）同样只适用于不需要用户态处理的程序

                2）传输描述符至少有一个是管道设备。

        2.2 优化零拷贝

            2.2.1  写时复制
                   在某些情况下，内核缓冲区可能被多个进程所共享，如果某个进程想要这个共享区进行 write 操作，
                   由于 write 不提供任何的锁操作，那么就会对共享区中的数据造成破坏，写时复制就是 Linux 引入来保护数据的。

                   写时复制，就是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么就需要将其拷贝到自己的进程地址空间中，
                   这样做并不影响其他进程对这块数据的操作，每个进程要修改的时候才会进行拷贝，所以叫写时拷贝。这种方法在某种程度上能够降低系统开销，如果某个进程永远不会对所访问的数据进行更改，那么也就永远不需要拷贝。

            2.2.2   缓存区共享

                这种方法完全改写 I/O 操作，因为传统 I/O 接口都是基于数据拷贝的，要避免拷贝，就去掉原先的那套接口，重新改写，所以这种方法是比较全面的零拷贝技术，目前比较成熟的一个方案是最先在 Solaris 上实现的 fbuf （Fast Buffer，快速缓冲区）。

                Fbuf 的思想是每个进程都维护着一个缓冲区池，这个缓冲区池能被同时映射到程序地址空间和内核地址空间，内核和用户共享这个缓冲区池，这样就避免了拷贝。

   参考链接： https://zhuanlan.zhihu.com/p/78388827