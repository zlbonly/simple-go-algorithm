
Linux零拷贝技术

   1、为什么需要零拷贝。
          传统的 Linux 系统的标准 I/O 接口（read、write）是基于数据拷贝的，也就是数据都是 copy_to_user 或者 copy_from_user，
          这样做的好处是， 通过中间缓存的机制，减少磁盘 I/O 的操作，但是坏处也很明显，大量数据的拷贝，用户态和内核态的频繁切换，
          会消耗大量的 CPU 资源，严重影响数据传输的性能，有数据表明，在Linux内核协议栈中，
          这个拷贝的耗时甚至占到了数据包整个处理流程的57.1%。

          linux 原始数据拷贝。例如：某个应用程序需要从磁盘读取某个内容，然后通过网络发送出去，

          while((n = read(diskfd, buf, BUF_SIZE)) > 0)
              write(sockfd, buf , n);

              大致经过的流程：
              1、read()将数据从磁盘文件，通过DMA（Direct Memory Access 直接内存读取）等方式拷贝到内核开辟的缓冲区。
              2、数据从内核缓冲区复制到 用户缓冲区
              3、write() 将数据从用户态缓冲区复制到内核协议栈开辟的socket缓冲区
              4、数据从socket缓冲通过DMA拷贝到网卡发送出去。


   2、 什么是零拷贝
            零拷贝是解决1问题的一种解决方案，通过尽量避免拷贝操作来缓解CPU压力。
            Linux 下常见的零拷贝技术可以分为两大类：一是针对特定场景，去掉不必要的拷贝；二是去优化整个拷贝的过程。
            由此看来，零拷贝并没有真正做到“0”拷贝，它更多是一种思想，很多的零拷贝技术都是基于这个思想去做的优化。


        2.1 特定场景的零拷贝

            2.1.1 直接I/O

            2.1.2 mmap

            2.1.3 sendfile

            2.1.4 DMA 辅助的sendfile

            2.1.5 splice

        2.2 优化零拷贝

            2.2.1  写时复制

            2.2.2   缓存区共享