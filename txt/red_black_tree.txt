

各种树的区别对比：
    二叉查找树，AVL树，B树，B+树，红黑树

   1、 二叉查找树
    二叉查找树就是左结点小于根节点，右结点大于根节点的一种排序树，也叫二叉搜索树。也叫BST，英文Binary Sort Tree。

    二叉查找树比普通树查找更快，查找、插入、删除的时间复杂度为O（logN）。但是二叉查找树有一种极端的情况，就是会变成一种线性链表似的结构。此时时间复杂度就变为味了O（N），为了解决这种情况，出现了二叉平衡树。

    2、平衡二叉树
    平衡二叉树全称平衡二叉搜索树，也叫AVL树。是一种自平衡的树。

    AVL树也规定了左结点小于根节点，右结点大于根节点。并且还规定了左子树和右子树的高度差不得超过1。
    这样保证了它不会成为线性的链表。AVL树的查找稳定，查找、插入、删除的时间复杂度都为O（logN），但是由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行频繁的旋转。

    AVL树每一个节点只能存放一个元素，并且每个节点只有两个子节点。当进行查找时，就需要多次磁盘IO，（数据是存放在磁盘中的，每次查询是将磁盘中的一页数据加入内存，
    树的每一层节点存放在一页中，不同层数据存放在不同页。）这样如果需要多层查询就需要多次磁盘IO。为了解决AVL树的这个问题，就出现了B树。

    3、 B树
    B树也叫平衡树，也叫作B-树，英文为Blance-Tree。是一种多路平衡树。

    一个m阶的B树规定了：

    根结点至少有两个子女
    每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
    每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
    所有的叶子结点都位于同一层
    每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划
    B树每一层存放了更多的节点，由AVL树的“瘦高”变成了“矮胖”。可以相对减少磁盘IO的次数。MongoDB的索引就是用B树实现的。

    B树也是一种自平衡的树，在进行插入和删除操作时也需要对结点进行旋转等操作。

    不过，B树的查找不稳定，最好的情况就是在根节点查到了，最坏的情况就是在叶子结点查到。
    另外，B树在遍历方面比较麻烦，由于需要进行中序遍历，所以也会进行一定数量的磁盘IO。为了解决这些问题，出现了B+树。

    4、B+树
    B+树每个非叶子结点存放的元素只用于索引作用，所有数据保存在叶子结点。

    一个m阶的B+树规定了：

    有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
    所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
    所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
    因为非叶子结点中存放的元素不存放数据，所以每一层可以容纳更多元素，也就是磁盘中的每一页可以存放更多元素。这样在查找时，磁盘IO的次数也会减少。

    另外，B+树的查找稳定，因为所有的数据都在叶子结点。每个叶子结点也通过指针指向构成了一种链表结构，所以遍历数据也会简单很多。

    5、红黑树
    红黑树也叫RB树，RB-Tree。是一种自平衡的二叉查找树，它的节点的颜色为红色和黑色。
    它不严格控制左、右子树高度或节点数之差小于等于1。也是一种解决二叉查找树极端情况的数据结构。

    红黑树规定了：

    节点是红色或黑色。
    根节点是黑色。
    每个叶子节点都是黑色的空节点（NIL节点）
    每个红色节点的两个子节点都是黑色。也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点)。
    从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
    红黑树在查找方面和AVL树操作几乎相同。但是在插入和删除操作上，AVL树每次插入删除会进行大量的平衡度计算，红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。

    相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。

    红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的。

    Mysql为什么用b+数而不是红黑树：
    　b+树就是为文件存储而生的。如果数据库文件存储在主存中我认为两种结构的查询速度差距不是很大，因为主存的查找速度非常快。而数据库文件实际存储在磁盘中，定位一行信息需要查找该行文件所在柱面号，
    磁盘号，扇区号，页号这个阶段是很耗费时间的。每一次的定位请求意味着要做一次IO操作，也意味着成倍的时间消耗。因此减少IO查询的次数是提高查询性能的关键。而IO的查询次数就是索引树的高度，高度越低查询的次数越少。
    同样的结点次数红黑树的高度最多为2log(n+1)，而B+树的高度最多为(logt (n+1)/2)+1,随着t增大高度会更小，IO次数也会减少。

    Mysql为什么用b+树：
        1、因为在数据库中select常常不只是查询一条记录，常常要查询多条记录。比如：按照id的排序的后10条。如果是多条的话，B树需要做中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能够把所有数据取出来了。

一、红黑树

	红黑树是基于自平衡（不是绝对平衡）的二叉查找树，主要为了解决二叉查找树 顺序性一个单链表时查找效率问题。

 1、红黑树特性：
	1、每个节点要么红色，要么黑色
	2、跟节点黑色
	3、每个叶子节点nil 是黑色（注意！！！ 叶子节点 指 为nil 或者null的叶子节点）
	4、如果一个节点是红色，则它的子节点一定是黑色
	5、从节点（包括跟节点）到其任何后代null节点 的每一条路径都具有相同数量的黑色节点。

	如图1: https://github.com/zlbonly/timewheel/blob/master/pics/tree1.png

2、红黑树的操作

  1、左旋：
  		以某个节点作为支点（旋转节点），其右子节点变为旋转节点的父节点，右子节点的左子节点 变为旋转节点的右子节点，旋转节点的左子节点保持不变。
  		如图2: https://github.com/zlbonly/timewheel/blob/master/pics/tree2.png

  2、右选：
  		以某个节点作为支点（旋转节点），其左子节点变为旋转节点的父节点，左子节点的右子节点 变为旋转节点的左子节点，
  		旋转节点的右子节点保持不变。
  		如图3: https://github.com/zlbonly/timewheel/blob/master/pics/tree3.png

  3、变色：节点颜色由黑变红，或者由红变黑


3、红黑树查找流程
	因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：
	1、从根结点开始查找，把根结点设置为当前结点；
	2、若当前结点为空，返回null；
	3、若当前结点不为空，用当前结点的key跟查找key作比较；
	4、若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；
	5、若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；
	6、若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；


4、红黑树插入

	1、首先将红黑树 当作一个二叉查找树，先查找插入节点位置，将节点插入，
	2、然后将节点着色为红色，
	3、最后 通过旋转和重新着色来修正该树，使之重新成为一个二叉查找树


	注意！！！
		2、为什么着色成红色，而不是黑色呢？
	 将插入的节点着色为红色，不会违背"特性(5)"！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。

	 因此插入后 只会违背 特性4 （如果一个节点是红色，则它的子节点一定是黑色），只需要旋转调整 满足特性4即可。


 插入情景：
 	情景1: 红黑树为空树
 		处理：把插入结点作为根结点，并把结点设置为黑色

 	情景2: 插入节点的key已经存在
 		处理： 插入节点的key存在，既然红黑素总是保持平衡，在插入该节点前平衡，插入后也是平衡的
 		因此只需要 将加入节点的颜色 更改为 替换节点的颜色，然后更新值即可。

 	情景3: 插入节点的父节点是黑色的
 		处理：由于插入的节点是红色的，因此插入后不会影响红黑树的平衡，直接插入即可，不需要自平衡。

 	情景4: 插入节点的父节点是红色
 		如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。

 		1、情景4.1:  叔叔结点存在并且为红结点

 			从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如图4:
 			https://github.com/zlbonly/timewheel/blob/master/pics/tree4.png

 			处理：
 				将P和S设置为黑色
				将PP设置为红色
				把PP设置为当前插入结点

			根据图可以发现：
				可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。


		！！！ 试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。这也是唯一一种会增加红黑树黑色结点层数的插入情景

		2、插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点
			1、插入情景4.2.1：插入结点是其父结点的左子结点
			https://github.com/zlbonly/timewheel/blob/master/pics/tree5.png
				处理：
				1）将P设为黑色
				2）将PP设为红色
				3）对PP进行右旋

			2、插入情景4.2.2：插入结点是其父结点的右子结点

			这种情景显然可以转换为情景4.2.1，如图12所示，不做过多说明了。
			https://github.com/zlbonly/timewheel/blob/master/pics/tree6.png
			处理：
				对P进行左旋
				把P设置为插入结点，得到情景4.2.1
				进行情景4.2.1的处理



		3、插入情景4.3 叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点

			1、插入情景4.3.1：插入结点是其父结点的右子结点
			https://github.com/zlbonly/timewheel/blob/master/pics/tree7.png
			处理：
				将P设为黑色
				将PP设为红色
				对PP进行左旋

	        2、	插入情景4.3.2：插入结点是其父结点的左子结点
		https://github.com/zlbonly/timewheel/blob/master/pics/tree8.png
				处理：
					对P进行右旋
					把P设置为插入结点，得到情景4.3.1
					进行情景4.3.1的处理




红黑树删除：

		红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。

		二叉树删除结点找替代结点有3种情情景：

		情景1：若删除结点无子结点，直接删除
		情景2：若删除结点只有一个子结点，用子结点替换删除结点
		情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点

		补充说明下，情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点。那么可以拿前继结点（删除结点的左子树最右结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点。如图16所示。

		如图：https://github.com/zlbonly/timewheel/blob/master/pics/tree9.png


		接下来，讲一个重要的思路：删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！话很苍白，我们看图17。在不看键值对的情况下，图17的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！
		如图：https://github.com/zlbonly/timewheel/blob/master/pics/tree10.png


		基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1！

	情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）
	情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。
	二叉树删除结点情景关系图如图11所示。
	如图：https://github.com/zlbonly/timewheel/blob/master/pics/tree11.png
	综上所述，删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了


