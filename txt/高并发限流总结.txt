高并发系统三大利器：缓存、降级、限流

缓存：提升系统访问速度和增大处理容量，为相应业务增加缓存。
降级：当服务器压力剧增时，根据业务策略降级，以此释放服务资源保证业务正常。
限流：通过对并发限速，达到拒绝服务、排队、等候、降级等处理


1、缓存 参考分布式缓存总结

2、降级
    1、主动降级
        主动降级，降低非核心服务级别；保证自己的服务不被拖垮。
            （例如:企鹅体育 在cba总决赛期间，直播间内禁止充值，禁止用户修改信息等）
    2、被动降级 （我归结为熔断，一般是下游引起）
       一般指我们自己服务，检测到下游服务的成功率下跌严重时，可以切换为不依赖该下游服务的状态，保证自身主业务的正常运行。
3、限流


    2、常见的限流算法

        1、计数器
            计数器算法
            这是最容易理解和实现的算法，假设一个接口1s中最多请求100次。最开始设置一个计数器count=0，来一个请求count+1，1s之内count<=100的请求可以正常访问，count>100的请求则被拒绝，1s之后count被重置为0，重新开始计数

            当然这种方式有个弊端，1s内只有最开始的100个请求能正常访问，后面的请求都不能正常访问，即突刺现象。此时我们就可以用滑动窗口算法来解决这个问题，例如把1s分成5个时间段，每个时间段能正常请求20次。

        2、漏斗
        原理：
            漏斗算法的原理也很容易理解。请求来了之后会首先进到漏斗里，然后漏斗以恒定的速率将请求流出进行处理，
            从而起到平滑流量的作用。当请求的流量过大时，漏斗达到最大容量时会溢出，此时请求被丢弃。从系统的角度来看，
            我们不知道什么时候会有请求来，也不知道请求会以多大的速率来，这就给系统的安全性埋下了隐患。但是如果加了一层漏斗算法限流之后，
            就能够保证请求以恒定的速率流出。在系统看来，请求永远是以平滑的传输速率过来，从而起到了保护系统的作用。
        特点分析

       1、 漏桶的漏出速率是固定的，可以起到整流的作用。即虽然请求的流量可能具有随机性,忽大忽小，但是经过漏斗算法之后
            变成了有固定速率的稳定流量，从而对下游的系统起到保护作用。
       2、 不能解决流量突发的问题。还是拿刚刚测试的例子，我们设定的漏斗速率是2个/秒，然后突然来了10个请求，受限于漏斗的容量，
            只有5个请求被接受，另外5个被拒绝。你可能会说，漏斗速率是2个/秒，然后瞬间接受了5个请求，这不就解决了流量突发的问题吗？
            不，这5个请求只是被接受了，但是没有马上被处理，处理的速度仍然是我们设定的2个/秒，所以没有解决流量突发的问题。
            而接下来我们要谈的令牌桶算法能够在一定程度上解决流量突发的问题，读者可以对比一下。


        3、令牌桶算法(Token Bucket Algorithm)
        算法原理 令牌桶算法会按照一定的速率生成令牌放入令牌桶,访问要进入系统时,需要从令牌桶获取令牌,有令牌的可以进入,
        没有的被抛弃.由于令牌桶的令牌是源源不断生成的,当访问量小时,可以留存令牌达到令牌桶的上限,这样当短时间的突发访问量来时,
        积累的令牌数可以处理这个问题.当访问量持续大量流入时,由于生成令牌的速率是固定的,最后也就变成了类似漏斗算法的固定流量处理.

        实现方式和漏斗也比较类似,可以使用一个队列保存令牌,一个定时任务用等速率生成令牌放入队列,访问量进入系统时,从队列获取令牌再进入系统.


       golang 令牌桶实现 ：golang.org/x/time/rate
       令牌桶设计概念：

       令牌：每次请求只有拿到 Token 令牌后，才可以继续访问；
       桶：具有固定数量的桶，每个桶中最多只能放设计好的固定数量的令牌；
       入桶频率：按照固定的频率往桶中放入令牌，放入令牌不能超过桶的容量。

        具体实现：
        type Limiter struct {
            mu        sync.Mutex // 互斥锁（排他锁）
            limit     Limit      // 放入桶的频率  float64 类型
            burst     int        // 桶的大小
            tokens    float64    // 令牌 token 当前剩余的数量
            last      time.Time  // 最近取走 token 的时间
            lastEvent time.Time  // 最近限流事件的时间
        }


       使用：以上就表示每 100ms 往桶中放一个 Token。本质上也就是一秒钟产生 10 个。

        limit := Every(100 * time.Millisecond);
        limiter := NewLimiter(limit, 1);

        Limiter 提供了三类方法供用户消费 Token，用户可以每次消费一个 Token，也可以一次性消费多个 Token

        1、Allow 和 AllowN
        Allow 实际上就是 AllowN(time.Now(),1)。
        AllowN 方法表示，截止到某一时刻，目前桶中数目是否至少为 n 个，满足则返回 true，同时从桶中消费 n 个 token。
        反之返回不消费 Token，false。