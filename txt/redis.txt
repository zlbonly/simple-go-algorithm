
   Redis 实现和分析

 一、基本数据结构
1、简单动态字符串 （SDS）
Redis没有直接使用 C 语言的字符串，而是自己创建了名为 SDS (simple dynamic string, SDS) 的字符串。

  1） redis 3.2之前版本实现
    在redis3.2.x之前，SDS的存储结构如下：
    struct sdshdr {
        int len; //存长度
        int free; //存字符串内容的柔性数组的剩余空间
        char buf[]; //柔性数组，真正存放字符串值
    };

    Redis 3.2 之前的SDS主要是通过int len; int free; char buf[];这三个字段来确定一个字符串的。其中len表示buf中已占用字节数，free表示buf中剩余可用字节数，buf是数据空间。

    优点：
        1、有单独的统计变量len和free（称为头部），可以很方便的得到字符串的长度。
        2、内容存放在柔性数组buf中，SDS对上层暴露的指针不是指向结构体SDS的指针，而是直接指向柔性数组buf的指针。上层可以像读取C字符串一样读取SDS的内容，兼容C语言处理字符串的各种函数。
        3、由于有长度的统计变量len的存在，读写字符串时不依赖“0”终止符，保证了二进制安全。

    为什么要用柔性数组？
    柔性数组的地址和结构体是连续的，这样查找内存更快（因为不需要额外通过指针找到字符串的位置）；
    可以更快的通过柔性数组的首地址偏移得到结构体首地址，进而能很方便的获取其余变量。

    3.2版本之前的缺点：不同长度的字符串需要占用相同大小的头部，显然是浪费了空间。

    2） redis 3.2及 3.2之后版本实现 （改进以5.0+ 为例子）
        struct  __attribute__ ((__packed__) ) sdshdr16 {
            uint16_t len; //字符串长度
            uint16_t alloc; // //已分配的总空间
            unsigned char flags; // 标识是哪种存储类型
            char buf[]; //存储字符串内容的柔性数组
        };


        redis 3.2及之后的版本 根据字符串的长度，分成了5种类型sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64。
        并且 sdshdr5居然没有头部（len和alloc），而其他四种数据结构，多了一个flags字段。

         sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64 四种结构的成员变量类似，唯一的区别是len和alloc的类型不同。结构体中4个字段的具体含义如下：
         1、len表示buf中已占用字节数。
         2、alloc表示buf中已分配字节数，记录的是为buf分配的总长度，不同于free。
         3、flags标识当前结构体的类型，低3位用作标识位，高5位预留。
         4、buf柔性数组，真正存储字符串的数据空间。
            创建SDS的大致流程是，首先计算好不同类型的头部和初始长度，然后动态分配内存。需要注意的是：
        1、创建空字符串是SDS_TYPE_5会被强制转换为SDS_TYPE_8。
        2、长度计算时有“+1”操作，是为了算上结束符“0”。
        3、返回值是指向sds结构buf字段的指针

 补充知识：
     C 语言中，用 “\0” 表示字符串的结束，如果字符串本身就有 “\0” 字符，字符串就会报截断，既非二进制安全，若通过某种机制，保证写字符串时不会受损坏的内容，则是二进制安全。

1.2、动态字符串（SDS）的好处
    1、常数复杂度获取字符串长度
        SDS使用结构体实现，结构体中的len属性直接记录了该SDS结构体中buf数组中已使用的长度，因此获取字符串长度时，只需要获取len属性的值，这个操作的复杂度为O(1)。
    2、杜绝缓冲区溢出
        因为C字符串不记录自身的长度，所以当进行字符串复制的时候，如果分配内存不够，便有可能产生缓冲区溢出。
        而在Redis中，当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。
    3、减少修改字符串时带来的内存重分配次数
        常规C字符串，再执行拼接操作或者截断操作时，通常会对数组进行内存重分配，而内存重分配操作涉及复杂的算法，并且可能执行系统调用，所以它通常是一个比较耗时的操作。
        Redis作为数据库，会对数据进行频繁的修改，并且对速度要求极为严苛，所以每次修改字符串长度都需要进行内存重分配会对性能造成极大的影响
        因此，SDS实现了空间预分配和惰性空间释放两种优化策略。

        1） 空间预分配
            在需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。
            举一个例子，我们将字符串“Redis”扩展到“Redis111”，应用程序并不仅仅分配3个字节，仅仅让它恰好满足分配的长度，而是会额外分配一些空间。
            具体如何分配，见下述代码注释。我们讲其中一种分配方式，假设它会分配8字节的内存空间。现在总共的内存空间为5+8 = 13，而我们只用了前8个内存空间，还剩下5个内存空间未使用。
            那么我们为什么要这样做呢？这是因为如果我们再继续对它进行扩展，如改成“Redis11111”，在扩展 SDS 空间之前，SDS API 会先检查未使用空间是否足够，如果足够的话，
            API 就会直接使用未使用空间那么我们就不用再进行系统调用申请一次空间了，直接把追加的“11”放到之前分配过的空间处即可。这样一来，会大大减少使用内存分配系统调用的次数，提高了性能与效率

            sds sdsMakeRoomFor(sds s, size_t addlen) {

                void *sh, *newsh;
                size_t avail = sdsavail(s); // 获取当前字符串可用剩余空间
                size_t len, newlen;
                char type, oldtype = s[-1] & SDS_TYPE_MASK;
                int hdrlen;

                /* 如果可用空间大于追加部分的长度，说明当前字符串还有额外的空间，足够容纳扩容后的字符串，不用分配额外空间，直接返回 */
                if (avail >= addlen) return s;

                len = sdslen(s);
                sh = (char*)s-sdsHdrSize(oldtype);
                newlen = (len+addlen);
                if (newlen < SDS_MAX_PREALLOC) //SDS_MAX_PREALLOC = 1MB，如果扩容后的长度小于1MB，直接额外分配扩容后字符串长度*2的空间
                    newlen *= 2;
                else
                    newlen += SDS_MAX_PREALLOC; //扩容后长度大于等于1MB，额外分配扩容后字符串+1MB的空间

                 ...
                 真正的去分配空间
                 ...
                 sdssetalloc(s, newlen);
                 return s;
            }

        2）惰性空间释放
            惰性空间释放用于优化 SDS 的字符串截取或缩短操作。当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即回收缩短后多出来的字节，是使用free/alloc来记录这些数量。这样一来，如果将来要对 SDS 进行增长操作的话，这些未使用空间就可能会派上用场。
            比如我们将“Redis111”缩短为“Redis”，然后又改成“Redis111”，这样，如果我们立刻回收缩短后多出来的字节，然后再重新分配内存空间，是非常浪费时间的。
            如果等待一段时间之后再回收，可以很好地避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了扩展空间


1.3、SDS 常见面试题：
    1、SDS如何兼容C语言字符串？如何保证二进制安全？
        SDS对象中的buf是一个柔性数组，上层调用时，SDS直接返回了buf。由于buf是直接指向内容的指针，所以兼容C语言函数。而当真正读取内容时，SDS会通过len来限制读取长度，而非“0”，所以保证了二进制安全。
    2、sdshdr5的特殊之处是什么？
        sdshdr5只负责存储小于32字节的字符串。一般情况下，小字符串的存储更普遍，所以Redis进一步压缩了sdshdr5的数据结构，将sdshdr5的类型和长度放入了同一个属性中，用flags的低3位存储类型，高5位存储长度。创建空字符串时，sdshdr5会被sdshdr8替代。

    3、SDS 如何动态扩容 （参考空间预分配）

2. 链表
    ／/链表节点
    typedef struct listNode {
        struct listNode *prev;  // 前置节点
        struct listNode *next;  // 后置节点
        void *value; // 节点的值，任意的类型
    } listNode;

    //链表
    typedef struct list {
        listNode *head; // 表头节点
        listNode *tail; // 表尾节点
        void *(*dup)(void *ptr);  // 节点值复制函数
        void (*free)(void *ptr);   // 节点值释放函数
        int (*match)(void *ptr, void *key);  // 节点值对比函数
        // 链表所包含的节点数量
        unsigned long len;
    } list;

在Redis中，还特殊的定义了一个迭代器，专门用来迭代，记录迭代的方向与当前迭代的节点：

typedef struct listIter {
    listNode *next;    // 当前迭代到的节点
    int direction;    // 迭代的方向
} listIter;

Redis中链表的主要特性主要如下：
1、多态：这是Redis链表中最重要的特点，在链表定义里使用函数指针来定义复制、释放与比较函数，将具体实现交予其它模块，类似于在这定义了三个接口，而且大量使用void指针，使其可以指向任何的数据类型，这也是Redis整体的特征。
2、尽可能少的时间花销：从上述代码不难看出，Redis为了减少在时间上的开销，自带了链表长度的计数器len，以及表头与表位指针，从而使得获取长度、头结点与尾节点的时间复杂度为O(1)，而且在插入一个新的节点时，Redis会使用前插法使得插入节点的时间复杂度也为O(1)。



2 、redis 字典
    Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典的一个键值对。
   1、哈希表节点
    typedef struct dictEntry {
        void *key; // 键
        union {   // 值
            void *val;
            uint64_t u64;
            int64_t s64;
        } value;
        struct dictEntry *next;  //指向下个哈希表节点，形成链表

    } dic

    2 、哈希表
       typedef struct dictht {
           dictEntry **table; // 哈希表数组
           unsigned long size; // 哈希表大小
           unsigned long sizemask; //  哈希表大小掩码，用于计算索引值（总是等于 size - 1）
           unsigned long used;  // 该哈希表已有节点的数量
       } dictht;

    3、字典
      typedef struct dict {
          dictType *type; //  类型特定函数
          void *privdata; // 私有数据
          dictht ht[2]; // 哈希表
          // rehash 索引当 rehash 不在进行时，值为 -1
          int rehashidx; /* rehashing not in progress if rehashidx == -1 */
          //  目前正在运行的安全迭代器的数量
          int iterators; /* number of iterators currently running */

      } dict;

      说明：（ht 属性包含两个项的数组，数组中的每一项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]
      哈希表进行rehash时使用。rehashidx 记录当前的进度，如果目前没有在进行rehash ，那么它的值为-1）


    4、 哈希表解决键冲突：
        当有两个或者以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称为这些键冲突

        解决方案： 哈希表使用链地址法 来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上
        的多个节点可以用这个单向链表连接起来。（redis总是将新节点添加到链表的表头位置（复杂度为O(1))）,排在其他节点的前面。
    5、重新散列 rehash(扩展和压缩)
       1、rehash过程
           1）为字典的h[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）
                i） 如果执行的是扩展操作，那么ht[1]的大小为第一个大于/等于 ht[0].used * 2 的（2的n次方）
                ii) 如果执行的是收缩操作，那么ht[1]的大小为第一个大于/等于 ht[0].used的2的n次方
            2）将保存在ht[0]中的所有键值对rehash到ht[1]上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上

            3） 当ht[0】包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0],将ht[1]设置为ht[0],并在ht[1]新建一个空白哈希表，为下一次rehash作准备。

    6、渐进式rehash 和 rehash执行期间的哈希表操作。
         为了避免rehash对服务器性能造成影响，服务器不是一次性的将ht[0]里面的所有键值对全部rehash到ht[1],而是分多次，渐进式的将ht[0]里面的
         键值对慢慢的rehash到ht[1].

         在渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个hash表，所以在渐进式rehash期间，字典的删除（delete）,查找(find),更新（update）
         等操作会在两个哈希表上进行。例如，要在字典中查找一个键的话，程序会先在ht[0]里面进行查找，如果没有找到的话，就会继续到ht[1]里面进行查找。
          另外。在渐进式rehash执行期间，新添加到字典的键值对，一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对
          数量会只减不增，并随着rehash操作的执行而最终变成空表。

3、redis 跳跃表（skiplist）
    跳跃表（skiplist）是一种有序的数据结构，他通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O(logN) ,最坏O（N）复杂度的节点查找
    ，还可以通过顺序性操作来批量处理节点。

    Redis使用跳跃表作为Zset的实现.

    1、 zskiplistNode 节点

    /* ZSETs use a specialized version of Skiplists */

    typedef struct zskiplistNode {
        sds ele;
        double score;
        struct zskiplistNode *backward;
        struct zskiplistLevel {
            struct zskiplistNode *forward;
            unsigned long span;
        } level[];
    } zskiplistNode;

    字段说明：
    i） * backward （后退指针：用于从表尾部向表头部访问节点，每个节点只有一个后退节点，每次只能后退至前一个节点。）
    2）score 和 ele( *obj) : 分值和成员， score是一个double浮点数，跳跃表中的所有节点都按分值大小进行排序。
       *obj成员对象是一个指针，指向一个字符串对象，而字符串对象保存着一个SDS值。
       分数值相同的节点，按照成员对象在字典序中的大小来进行排序。
    3） 层level
           跳跃表的节点level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针和 跨度。
           每次创建新的跳跃表节点的时候，redis都会根据幂次定律随机生成一个介于1～32的值作为level数组的大小，这个值就是level

        zskiplistNode *forward： 每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点。
        unsigned long span： 层的跨度用于记录两个节点之间的距离。


    2、zskiplist 用于保存跳跃表节点 （ 跳表结构管理节点）
    typedef struct zskiplist {
        struct zskiplistNode *header, *tail;
        unsigned long length; //     // 长度
        int level; //     // 跳表高度(所有节点最高层高)
    } zskiplist;

    3、zset结构

    typedef struct zset {
        dict *dict;
        zskiplist *zsl;
    } zset;

    3、zset 之所以使用跳跃表 本质在于解决 "查找问题"
        普通链表结构： value1(score1) -> value2(score2) -> value3(score3) ->value4(score4)
        我们需要这个链表按照 score 值进行排序，这也就意味着，当我们需要添加新的元素时，我们需要定位到插入点，这样才可以继续保证链表是有序的，
        通常我们会使用 二分查找法，但二分查找是有序数组的，链表没办法进行位置定位，
        我们除了遍历整个找到第一个比给定数据大的节点为止 （时间复杂度 O(n)) 似乎没有更好的办法。

    但假如我们每相邻两个节点之间就增加一个指针，让指针指向下一个节点,这样所有新增的指针连成了一个新的链表，但它包含的数据却只有原来的一半
    样所有新增的指针连成了一个新的链表，但它包含的数据却只有原来的一半
    现在假设我们想要查找数据时，可以根据这条新的链表查找，如果碰到比待查找数据大的节点时，再回到原来的链表中进行查找，

    zset跳跃表就是利用这一原理。

   4、新增和更新跳跃表节点
        skiplist 为了避免插入节点后，顺序性被打乱需要在平衡问题，它不要求上下相邻两层链表之间的节点个数（1：2）有严格的对应关系，而是 为每个节点随机出一个层数(level)。
        比如，一个节点随机出的层数是 3，那么就把它链入到第 1 层到第 3 层这三层链表中
        参考（https://segmentfault.com/a/1190000022028505）


4、redis 压缩列表(ziplist) 和 quicklist(快速列表)
    压缩列表是Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。
        Redis的有序集合、哈希以及列表都直接或者间接使用了压缩列表。当有序集合或哈希的元素数目比较少，
        且元素都是短字符串时，Redis便使用压缩列表作为其底层数据存储方式。列表使用快速链表（quicklist）数据结构存储，
        而快速链表就是双向链表与压缩列表的组合

        1、字节数组（Redis使用字节数组表示一个压缩列表，字节数组逻辑划分为多个字段）
            zlbytes | zltail | zllen | entry1 | entry2 | ......zlend

            1、zlbytes：压缩列表的字节长度，占4个字节，因此压缩列表最长(2^32)-1字节；
            2、zltail：压缩列表尾元素相对于压缩列表起始地址的偏移量，占4个字节；
            3、zllen：压缩列表的元素数目，占两个字节；那么当压缩列表的元素数目超过(2^16)-1怎么处理呢？此时通过zllen字段无法获得压缩列表的元素数目，必须遍历整个压缩列表才能获取到元素数目；
            4、entryX：压缩列表存储的若干个元素，可以为字节数组或者整数；entry的编码结构后面详述；
            5、zlend：压缩列表的结尾，占一个字节，恒为0xFF。


        2、压缩列表节点
           每个压缩列表节点都是由 previous_entry_length ,encoding,content三个部分组成。
            i) previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度。
                主要用于压缩列表遍历（使用指向当前节点起始节点指针C，减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个
                节点起始地址的指针p）。
            ii） encoding： 记录content属性所保存数据的类型及长度
            iii) content : 节点保存的值 （可以是字节数组/整数），具体类型和长度 由节点encoding属性决定。


       3、连锁更新 （新增和删除压缩列表节点，可能导致压缩列表执行空间重分配操作，但是概率极低，redis本身忽略，）
        参考：
        https://segmentfault.com/a/1190000017328042

    5、redis对象 （redisObject）
        redis没有使用 简单动态字符串（SDS）,链表，字典，压缩链表，集合 等这些数据结构来实现键值对 数据库，而是基于这些数据结构创建了一个
        对象系统，这个系统包含字符串对象，列表对象，哈希对象，集合对象和有序集合对象。没种对象都实现了至少一种前面提到的数据结构。


        1、redis 使用对象来表示数据库中的键和值，每次新建一个键值对时，会创建两个对象，一个对象用作键值对的 键（键对象），另一个对象
        用作键值对的值（值对象）

        redisObject对象 数据结构：

        typedef struct redisObject{

            unsigned type:4; // 类型

            unsigned encoding:4; // 编码

            void *ptr; // 指向底层实现数据结构的指针

           unsigned lru:22 // lru属性 该属性记录了对象最后一次被命令程序访问的时间。
           refcount
        }

        一般来说。对象的ptr指针 指向对象的底层实现数据结构，是这些数据结构由对象的encoding属性决定。


         2、对象内存回收
            redisObject 使用 refcout 引用记数的机制实现内存回收。当一个对象不再被使用时，该对象所占用的内存就会被自动释放。
         3、对象共享
            Redis会共享值为0 ~ 9999的字符串对象


         4、对象的空转时间
               Redis使用 lru属性 记录自己被最后一次访问的时间。根据这个时间可以用于计算对象的空转时间（当前时间 减去对象的lru时间）

               空转时间作用：当服务器打开了maxmemory选项时，并且服务器用于回收内存的算法为：volatile-lru 或者allkeys-lru时
               那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而内存回收。



    6、redis 键的过期策略  和 内存回收策略


    7、redis 持久化  RDB&AOF
        1、RDB
            RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，
            默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据

            1） 开启RDB持久化方式
                1） save命令
                       当客户端向服务器发送save命令请求进行持久化时，服务器会阻塞save命令之后的其他客户端的请求，直到数据同步完成。
                        如果数据量太大，同步数据会执行很久，而这期间Redis服务器也无法接收其他请求，所以，最好不要在生产环境使用save命令。

                2） bgsave命令
                    1、当客户端发服务发出bgsave命令时，Redis服务器主进程会forks一个子进程来解决数据同步问题，在将数据保存到rdb文件之后，子进程会退出。
                    2、所以，与save命令相比，Redis服务器在处理bgsave采用子线程进行IO写入，而主进程仍然可以接收其他请求，但forks子进程是同步的，所以forks子进程时，一样不能接收其他请求，这意味着，如果forks一个子进程花费的时间太久(一般是很快的)，bgsave命令仍然有阻塞其他客户的请求的情况发生。
                    3、我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。

                3） 通过配置文件自动触发
                自动触发的场景主要是有以下几点：

                1.根据我们的 save m n 配置规则自动触发；
                2.从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 bgsave；
                3.执行 debug reload 时；
                4.执行shutdown时，如果没有开启aof，也会触发。
                eg: save 900 1   #900s内如果有1条数据写入，就产生RDB快照

                配置文件自动生成rdb文件后台使用的是bgsave方式。

             特别说明 bgsave 命令： 其实是一种写时复制的机制
                1、fork创建出的子进程，与父进程共享内存空间。也就是说，如果子进程不对内存空间进行写入操作的话（Redis的子进程只做数据落盘的操作，也不会去写数据），
                内存空间中的数据并不会复制给子进程，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间，玩的是指针)。
                2、当Redis父进程修改数据时，父进程会将原先的数据复制一份生成新的副本，然后修改父进程的指针，指向新的数据，此时父进程修改的新的数据不会影响到子进程。此时子进程的指针仍然指向旧的数据，
                子进程看到的数据还是bgsave时候的数据。当下一次执行bgsave时，新fork出来的子进程指针才会指向这次新的数据。

          2、AOF
                与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以追加的方式保存到以后缀为aof文件中，
                在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。
                1、开启AOF的方式
                    方式一：bgrewriteaof命令
                    方式二：通过配置文件自动触发 redis默认不开启AOF持久化方式，我们可以在配置文件中开启并进行更加详细的配置：

                2、AOF 重写
                    重写
                    AOF将客户端的每一个写操作都追加到aof文件末尾，比如对一个key多次执行incr命令，这时候，aof保存每一次命令到aof文件中，aof文件会变得非常大。

                    后台重写（bgrewriteaof):
                    在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新的AOF文件期间，记录服务器执行的所有写命令。
                    当子进程完成创建新的AOF文件的工作后，服务器会将重写缓冲区中的所有内容追加到新的AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。
                    最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。


                    ！！！ 注意： 不管是RDB还是AOF都是先写入一个临时文件，然后通过 rename 完成文件的替换工作。
                    参考连接：https://juejin.cn/post/6935983097347309604#heading-7


           3、混合持久化
            重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，
            这样在 Redis 实例很大的情况下，启动需要花费很长的时间。Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。
            通过如下配置可以开启混合持久化(前提必须先开启aof):
            aof‐use‐rdb‐preambleyes #开启混合持久化

            过程：
            如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，
            都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。于是在 Redis 重启的时候，可以先加载 RDB 的内容，
            然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。



