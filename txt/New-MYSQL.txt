

1、MyIsam 和 Innodb区别
    1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
    2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；
    3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。
        但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。
        而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
    4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
    5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。
        这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

    MyISAM引擎中 也是使用b+tree作为索引数据结构，叶子结点的data域存放的是数据记录的地址。
    myIsam的索引文件，仅仅保存数据的记录
    myIsam 中，主索引和辅助索引在结构上没有区别，都是存放地址，只是主索引要求key是唯一的，而辅助索引的key可以重复。

2、索引覆盖
    1、索引覆盖，是指从非主键索引就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生，减少了数的搜索次数，提升查询的性能

    demo: student 表，现在name上建立有索引，但是年龄和name经常需要一起查询，因此可以删除name索引，建立name_age索引，
    select age,name from student时 就可以直接获取name,和age，而不需要在进行回表。

3、聚簇索引和非聚集索引（辅助索引/二级索引）
   1、聚集索引不是一种单独的索引类型，而是一种数据存储方式。索引键值的逻辑顺序，据定了表数据行的物理存储顺序。
   2、非聚集索引是逻辑上连续，物理存储上并不连续

   myisam 都是非聚集索引 （共3个文件.frm存储表定义，.MYD 存储扩展名，.MYI存储索引文件）
   innodb 主键索引是聚集索引，其他都是非聚集索引。（数据文件及索引文件）

4、联合索引和最左匹配
    1、在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
    2、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
    比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
        如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
    3、 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式


5、MYSQL 索引 （B+索引）


    总结：为什么使用B++ 树作为索引的数据结构
        1、先介绍，二叉树，二叉搜索树(avl)，红黑树，b树，b++存放数据优点。

        1、平衡二叉树
            平衡二叉树又被称为AVL树，本质还是二叉查找树
            平衡二叉树是一颗空树或者它的左右两个子树的高度差的绝对值不超过1，并且左右子树也是平衡树
            非叶子节点值大于左子节点值而小于右子节点值
            非叶子节点最多拥有两个子节点
        2、红黑树
            每个节点要么是红色要么是黑色
            根节点是黑色
            每个叶子节点(NIL)是黑色
            每个红色节点的两个子节点一定为黑色
            任意一个节点到每个叶子节点的路径都包含数量相同的黑色节点
            如果一个节点存在黑子节点，那么该节点肯定有两个子节点

        3、平衡二叉树 和 红黑树区别
         1、红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。

        4、B树又叫平衡多路查找树，
            每个节点中，都包含数据(key和data域)和指针，相互间隔
            叶节点具有相同的深度，叶节点的指针为空
            节点中的数据索引从左到右递增排列
            所有索引元素不重复

        5、B+树
            非叶子节点中不存储data，只存储索引，可以放更多的索引
            叶子节点包含所有索引字段
            叶子节点包含数据(key和data域)和指针
            叶子节点用指针连接，提高区间访问的性能
        InnoDB使用B+树的原因。
        1、avl树 和 红黑树 多用于内存排序，每个节点存放一个数据，相同数量的数据，树的深度太大，每次读取消耗大量的磁盘io
        2、B+树非叶子节点只存储key值，而B-树存储key值和data值，这样B+树每次读取时可以读取到更多的key值
        3、mysql进行区间访问时，由于B+树叶子节点之间用指针（双向链表）相连，只需要遍历所有的叶子节点即可；而B-树则需要中序遍历那样遍历
        4、B+树非叶子节点只存储key值，而B-树存储key值和data值，导致B+树的层级更少，查询效率更高
        5、 B+树所有关键词地址都存在叶子节点上，所以每次查询次数都相同，比B-树稳定


        innodb存储引擎一页的大小为16kb，一般主键类型为int占4个字节，或bigint占8个字节，指针类型页一般4个或8个字节，也就是说一个页中大概存储16*1024/16=1024个key，
        深度为3的B+tree索引（三页）可以维护1024*1024*1024=10亿条记录，实际情况每个节点不可能填满，
        B+tree的高度一般为2-4曾，mysql的innodb存储引擎将根节点常驻内存，也就是查找某一键值的行记录最多需要1-3次磁盘IO操作

   1)	二叉查找树
      首先，让我们先看一张图：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/mysql_temp1.jpeg
    二叉查找树分析：
       图中的圆为二叉查找树的节点，节点中存储了键（key）和数据 (data)。键对应user表中的id，数据对应user表中的行数据数据。
       二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。

       eg:
       如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：
       将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点>的右子节点作为当前节点。
       继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。
       把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。
       利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要 6 次才能找到。

    2) 平衡二叉树
        上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造：
        见图：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/mysql_temp2.jpeg
        这个时候可以看到我们的二叉查找树变成了一个链表。如果我们需要查找 id=17 的用户信息，我们需要查找 7 次，也就相当于全表扫描了。
        导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。

        为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。
        平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。
        如图3。
        https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/mysql_temp3.jpeg

        由平衡二叉树的构造我们可以发现第一张图中的二叉树其实就是一棵平衡二叉树。

        平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式这里就不介绍了。
        平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。


   3） B树
        因为内存的易失性。一般情况下，我们都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。
        但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。
        另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。
        如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。
        如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块。
        我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？
        可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘 IO，我们查找数据的效率将会极低！

        如图4：
            https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/mysql_temp4.jpeg

           为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树
           B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树：
           如图5： https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/mysql_temp5.jpeg

         图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。

         图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。

         从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。
         基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。
         eg:
         假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下：
         先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么我们根据页 1 中的指针 p2 找到页 3。
         将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。
         将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）


    4) B+ 树
            B+ 树是对 B 树的进一步优化。让我们先来看下 B+ 树的结构图：
            如图6：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/mysql_temp6.jpeg


       根据上图我们来看下 B+ 树和 B 树有什么不同：

       ①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。

       之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。

       如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。

       另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。

       一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。

       ②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。

       那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。

       有心的读者可能还发现上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。

       其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。

       也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。

       通过上图可以看到，在 InnoDB 中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。

       MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。

    二、聚集索引 VS 非聚集索引
    在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。

    那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。

    这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引：

    ①聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。

    这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。

    这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。

    ②非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。

    非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。

    明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：数据即索引，索引即数据。


参考连接：   http://www.liuzk.com/410.html


6、事务的隔离级别和 ACID特性
	在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务，事务处理可以用来维护数据库的完整性。

	ACID 特性：
		1、原子性（atomicity）
　　一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

	2、一致性（consistency）

     数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）

	3、隔离性（isolation）

     通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）

	4、持久性（durability）
　　  一旦事务提交，则其所做的修改不会永久保存到数据库。

	注意： 事务的原子性和持久性 通过redo log(重做日志) 来实现，事务的持久性通过undo log 来实现。

		Innodb 引擎 通过 Force Log at Commmit 机制 实现事务的持久性和一致性。即当事务提交时，必须先将事务的所有日志写入重做日志文件，进行持久化，直到事务的Commited操作完成才算完成。（该日志 包括 redo log 和 undo log）
		1、Redo log
			重做日志用来实现事务的持久性和原子性。其有两部分组成：一是内存中的重做日志缓存（redo log buffer），二是重做日志文件（redo log file）

		2、Undo log
			undo log 主要用来实现事务的回滚和MVCC操作。当对数据库进行修改时，InnoDB 引擎不仅会产生redo，还会产生一定量的undo 。如果执行的事务和语句由于某种原因失败了，又或者用户执行了一条RollBAck请求回滚，就可以利用undo信息将数据也回滚到修改之前的样子。

			 undo log 另一个作用实现MVCC。当用户读取一行数据时，若该记录已经被其他事务占用，当然事务可以通过undo读取之前的行版本信息，即实现一致性非锁定读取。

			 undo log 也会产生 redo log . 因为undo log 也需要执行久化保护。
			 Innnodb 引擎需要执行fsync 刷盘操作吧 重做日志缓存 刷新到 磁盘文件中。



	在数据库中，为了有效的保证并发读取数据的正确性，提出了事务隔离级别

	1、Read UnCommitted  未提交读 。（允许脏读，也就是可能读取到其他会话中未提交事务修改的数据）
	2、Read Committed    已提交读 （只能读取到已经提交的数据。但是存在不可重复读的问题）
	3、Repeated Read 	 可重复读 （在同一个事务中内的查询都是和事务开始时候一致的。可重复读隔离级别，是InnoDb 的默认隔离级别。该级别消除了不可重复读，但是存在幻读现象）
	4、Serializable 串行读（完全串行化的读，每次读都需要获得表级的共享锁，读写都会被组塞）
		这个级别的实现很简单，读加共享锁，写加排它锁，读写互斥。使用的是悲观锁的理论，实现比较简单，数据安全，但是并发能力弱


	不可重复读 和 幻读的区别：
		不可重复读重点在于update 和 delete ，而幻读的重点在于insert.
		在可重复读隔离级别中，当前sql第一次读取到数据的时候，就将这些数据加锁，其他事务无法修改这些数据，就可以实现重复读取了。但是该方法无法锁住insert的数据，所以事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名多了一条之前没有的数据，这就是幻读。幻读不能通过行锁来解决，需要使用Serializable隔离级别。


2、锁
	1、共享锁（S） 和排它锁（X）
		共享锁：
			共享所被称为读锁或者 S 锁，就像以上所述，共享锁在新请求访问一个数据的时候，如果是读请求则允许，如果是写（删改）请求，则不允许。由于共享锁允许其他的读操作，所以通常情况下共享锁只应用于 select 操作，如果一个 update 或者 delete 操作应用共享锁会发生很严重的数据不一致情况。

		排它锁：
			独占锁也被称为排它锁或者 X 锁，相对于共享锁，独占锁采用的态度比较坚决，一旦数据被独占锁锁定，其他任何请求（包括读操作）都必须等待独占锁的释放才可以继续，只有当前锁定数据的请求才可以修改读取数据。

	2、悲观锁和乐观锁
		乐观锁和悲观锁 是两种思想主要解决 数据竞争时候的并发问题

		乐观锁：


		悲观锁：

			悲观锁是指 数据对外界的修改保持保守的态度，在整个数据修改过程中，数据处于锁定状态。（读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。）
			在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读

		乐观锁：
			相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

			乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一




3、一致性非锁定读

	1、一致性非锁定读 是指InnoDB存储引擎通过行版本控制的方式来读取当前执行时间数据库中的数据。
	如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反的，
	InnoDB引擎会读取行的一个快照数据。
	流程：
		1、sql query  -》 XLocked  -〉 直接返回 （Snapshot Data） (快照数据)

		说明： 快照数据是指该行的之前版本的数据，通过undo段来实现，而 undo用来在事务中回滚数据，因此读取
		快照数据没有额外的开销。

	2、一致性非锁定读机制，极大的提高了数据库的并发性。在InnoDB引擎默认的设置下，是默认的读取方式。但是快照数据可能不止一个，在不同的事务隔离级别中，快照数据读取的定义不同。
		1、在READ COMMITTED 在 读已提交隔离级别下，非锁定读总是读取被锁定行的最新一份的快照数据。
		2、在REPEATABLE READ 在可重复读隔离级别下，非一致性锁定读总是读取事务开始时的行数据版本。

		demo:
			会话a  											会话B
			 begin(开启事务)
		1、 select * from parent where id = 1
			 												begin 开启事务
			 												update paraent set id = 3 where id = 1;

		2、	 select * from parent where id = 1;
			 												Commit

		3、	 select * from parent where id =1;

			 Commit


		总结 ：
			1、在 读已提交隔离级别中，会话a  步骤3 查询不到数据，因为 当前行被锁定，读取改行版本最新的一个快照数据 id已经变成了3
			2、在 可重复读隔离级别中，总是读取事务开始的行快照数据。因此 会话A的步骤3 还是可以读取出id=1 的数据的。

4、一致性锁定读
	 在InnnoDB 的默认配置下，事务的隔离级别 为可重复读，使用的是一致性非锁定读，但是 在某些情况下，需要对数据的读取操作进行加锁以保证数据逻辑的一致性。
	 InnnoDB 引擎，通过
	 1、select  for  update (添加X锁)
	 2、select lock in share mode  （添加S锁）

	  支持对只读操作的 一致性锁定读。
	 	select for update 会给 当前读取的行加上一个 X锁（排它锁），其他事务不能对已锁定的行加锁 只能阻塞。


 5、什么是MVCC?
Innodb 引擎默认隔离级别是 可重复读（RR）, 并且 InnoDb 通过MVCC（多版本并发控制）来实现可重复读的，MVCC在MySQL的InnoDB中的实现？
	1、在InnoDb 中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际的操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。

	于是行，默认的隔离级别 可重复读（RR）下，增删改查就变成了：
	1、SELECT
		读取创建版本小于或者等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录，这样可以保证在读取之前记录是存在的。
	2、Insert
		将当前事务的版本号保存至行的创建版本号。
	3、UPDATE
		新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务的版本号。
	4、Delete
		将当前事务的版本号保存至行的删除版本号。

	 在介绍的时候 都可以引出 一致性锁定读和 一致性非锁定读 介绍。


6、InnoDB 引入锁的类型
	1、Record Lock（记录锁）： 在索引记录上加锁，即行锁，锁在当前行
	2、Gap Locks (间隙锁)： 在索引记录之间加锁，或者在第一个索引记录之前加锁，或者在最后一个索引记录之后加锁。
	3、Next-key Locks ： 在索引记录上加锁，并且在记录之前的间隙加锁，它相当于是RecordLocks 和 Gap Locks的一个结合。

	Mysql InnoDB 通过间隙锁解决了幻读问题。





7、分布式事务
	分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中。全局事务必须要求在其中的所有参与事务要么都提交，要么都回滚。在使用分布式事务中，InnoDB 存储引擎的事务隔离级别必须设置 Serializable

	1、MySQL 数据库也支持分布式事务
		InnoDB 引擎提供了对XA事务的支持，并且通过XA事务来支持分布式事务的实现。

		XA 事务 由一个或者多个资源管理器，一个事务管理器以及一个应用程序组成。
		分布式事务使用两段水提交的方式。
		1、在第一阶段，所有参与全局事务的节点都开始准备，告诉事务管理器他们准备好了。
		2、在第二阶段，事务管理器告诉资源管理器执行ROLLBACK 还是COMMIT。如果一个节点显示不能提交，则所有的节点都被告知要回滚。



8、Mysql 主从复制
	1、 复制是Mysql 数据库提供的一种高可用高性能的解决方案。mysql 的主从复制 是数据可以从一个Mysql 数据库服务器主节点复制到一个或者多个从节点。MySQL 默认采用异步复制方式。
	2、主从复制形式
		1、一主一从
		2、一主多从 （提高系统读性能）
		3、多主一从
	3、主从复制原理
		主从复制涉及三个线程 ，一个运行在主节点（log dump threa）,两个运行在从线程（I/O 线程，SQL线程）
		步骤：
		1、当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。

		2、当从节点上执行`start slave`命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。
		3、SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。
	4、主从好处
		1、读写分离。让主库负责写，从库负责读，提高系统系能
		2、高可用和架构扩展。（如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能）


9、为什么Mysql 的索引 要使用B+树而不是其它树形结构？比如B树。
	1、先介绍B树 和 B+树的索引知识
	2、然后总结：
		因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少了，指针少的情况下要保存大量的数据，只能增加树的高度，导致IO操作变多，查询性能变低。

10、索引优化 和联合索引
	1、建索引的几大原则
		1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

		2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

		3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

		4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

		5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

	2、MySQL提供了Explain可以分析SQL语句。Explain 用来分析 SELECT 查询语句。

	Explain比较重要的字段有：

	select_type : 查询类型，有简单查询、联合查询、子查询等
	key : 使用的索引
	rows : 预计需要扫描的行数
	possiable_key ： 可能用到的索引

	3、慢查询日志
		MySQL提供的一种慢查询日志记录，用来记录在MySQL查询中响应时间超过阀值的记录
	具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中

	show variables like '%slow_query_log%';
		* slow_query_log //是否开启，默认关闭，建议调优时才开启
	* slow_query_log_file //慢查询日志存放目录

