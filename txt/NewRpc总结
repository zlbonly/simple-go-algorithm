
1、RPC框架流程原理
    1、服务消费方(client)以本地调用方式调用服务
    2、client stub 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体
    3、client stub 将消息进行编码并发送到服务端
    4、server stub 收到消息后进行解码
    5、server stub 根据解码结果调用本地的服务
    6、本地服务执行并将结果返回给 server stub
    7、server stub 将返回导入结果进行编码并发送至消费方
    8、client stub 接收到消息并进行解码
    9、服务消费方(client)得到结果

    参考：链接：https://juejin.cn/post/6992867064952127524

2、GRPC的流程原理 同1 类似
    1、grpc 的Stub层，通过protobuf3协议,定义好服务接口、参数等生成.proto文件，通过工具protoc-gen-go生成客户端和服务端共用的对照表，
        想生成什么语言文件就用相应的插件，这样就实现了跨语言。
    2、gRPC RPCRuntime层基于HTTP/2，将调用网络包发送到服务器
    3、GRPC Server端。启动服务，并调用服务注册相关的方法。
    4、grpc 客户端。建立连接和绑定实现的接口

3、grpc的通信协议： protobuf3
        1、protobuf支持的字段类型
            如int32、int64、uint32、uint64、sint32、sint64、bool和enum，采用可变长编码，即varints。 可变长编码。
            sin32: 可变长编码，存储负数时建议使用
            bool： 布尔类型
            string : 字符串类型
            float: 固定占用4个字节，
            double：固定占用8个字节

        2、Protobuf原理
            protobuf会对proto协议文件进行序列化，最终转换成二进制数据，在这个转换过程中，protobuf做了一些优化，使得转换出来的二进制数据尽可能的小，同时也具有安全，编解码快等特点

            1、消息类型编码
                我们定义了一个Animal的消息类型，那protobuf是怎么把它编码成二进制的呢？
                1、其实它是把message转成一系列的key-value，key就是字段号，value就是字段值，大概这样子存：
                [tag1][value1][tag2][value2][tag3][value3]...
                2、解码时，会从左往右解析每一个key-value，假如遇到某个key-value无法解析了，那么就直接跳过，不会影响到其它key-value的解析。
                另外注意到，实际上存储的是tag-value，而不是key-value，根据key转换成tag，也是有公式的
                tag = (key << 3) | wire_type
                3、value也不是直接转成二进制就完事的，它会针对不同的数据类型做不过压缩编码
                    1、可变长编码类型
                            如int32、int64、uint32、uint64、sint32、sint64、bool和enum，采用可变长编码，即varints。 可变长编码。
                            Varint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示：1010 1100 0000 0010。


                    2、负数可变长编码类型
                        如果要表示的数是一个负数，采用上面所说的方式编码，就会占用很多字节，因为对于比较常用（数值比较大）的负数来说，转成补码后会有很多个1，也就是说占用的字节会比较多，
                        ，因此Google又新增加了一种数据类型，叫sint，专门用来处理这些负数，其实现原理是采用zigzag编码，zigzag编码的映射函数为：
                        ZigZag(n) = (n << 1) ^ (n << k)，k为31或者63
                            最终的效果就是把所有的整数映射为正整数，比如0->0, -1->1, 1->1, -2->3这样子，然后就可以用上面所说的编码方式进行编码了，解码时通过逆函数解析即可
                    3、固定字节数类型
                        这种就很简单了，直接固定字节数就行，比如fixed32，它固定占用4个字节。而且可以看到，protobuf中float和double也是固定占用4个字节和8个字节，并没有实现压缩。

                    4、string类型
                        按照固定的格式编码，格式为：value = length + content
                        其中length就是content占用的字节数，采用可变长编码，content就是string的具体内容。

        3、Protobuf优缺点

            优点：
            1、小：生成的字节流采用了各种压缩方式，相对xml和json这类文件更小。
            2、快：编解码基本都是位运算，也没有复杂的嵌套关系，速度快。
            3、安全：这里的安全，是指protobuf没有把字段名写入到字节流里，只是写入了字段号信息。另外，相对于xml和json来说，因为被编码成二进制，破解成本增大
            4、语言无关和平台无关：把proto文件转成字节流，可以采用不同的语言，也就是说整个编解码过程完全不依赖某种语言的特性。

            缺点：
            可读性差：因为最终是转成二进制流，不像xml和json能够直接查看明文。
4、HttP2.0
    1、HTTP1.X 存在的问题
        1、HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
        2、单向请求，只能由客户端发起。
        3、请求报文与响应报文首部信息冗余量大。
        4、数据未压缩，导致数据的传输量大




5、之前我自己简单实现过一个rpc的框架：（主要参考网上的博客）
    1、定义服务端和客户端消息的编码，序列化协议。
        1、采用encoding/gob 和 application/json
    2、定义服务端和客户端 网络传输的协议及框架。
        1、http协议，及httpClient （以后可以考虑采用netty网络通信框架）
    3、客户端。
        1、获取可用的服务链接。
        2、实现发送请求，接受并处理响应结果。
        3、负载均衡策略用的是 轮询&随机，也可以使用（一致性hash）
     4、服务端
        1、启动服务，通过反射将结构体映射为服务。
     5、实现一个简单的支持心跳保活的注册中心
        1、定时器每隔1s检测服务，从而实现心跳检测。
        2、把服务地址注册到一个map列表中维护。
     6、实现简单的超时的处理机制
        1、客户端超时。使用 context 包中 context.WithTimeout实现，控制权交给用户，控制更为灵活
        2、服务端超时。time.After() 结合 select+chan 完成。（服务端开启子协程处理请求，处理完成后，通过channel通知，并通过time.After监控处理是否超时）

6、HTTP 和 RPC 的区别
    1、两则都是应用调用另一个应用的解决方案
        1、暴露接口  使用http调用。
        2、远程过程调用rpc

    2、传输协议
        RPC，可以基于TCP协议，也可以基于HTTP协议
        HTTP，基于HTTP协议（在TCP协议之上进行封装）

    3、传输效率
        RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率
        HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，
        那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理

    4、性能消耗，主要在于序列化和反序列化的耗时
        RPC，可以基于高效的二进制传输
        HTTP，大部分是通过json来实现的，字节大小和序列化耗时
