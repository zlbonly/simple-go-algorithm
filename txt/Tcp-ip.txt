
二、TCP连接（三次握手/四次挥手）
报文中字段解释：
 1） 序号：seq序号，占32位，用来标识从TCP源端向目地端发送的字节流
 2） 确认号 ack号，占32位，期待收到对方下一个报文段的第一个数据字节的序号。
 3）标识位 （flags）共6哥，即URG,ACK,PSH,RST,SYN,FIN等。具体含义如下
 	（A）URG：紧急指针（urgent pointer）有效，值为1时表示某一位需要优先处理。
	（B）ACK：确认序号有效，一般为1。
	（C）PSH：接收方应该尽快将这个报文交给应用层。
	（D）RST：重置连接。
	（E）SYN：请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1。
	（F）FIN：发送断开连接请求。

1、三次握手

	三次握手 其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的
	接收能力和发送能力是否正常，指定自己的初始化序列号为后面的可靠性传送做准备。

	三次握手过程：

	1、第一次握手：
		客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN，此时客户端处于SYN_SEND状态 （
	首部的同步位SYN=1 ，初始化序号seq=x，SYN=1的报文段不能携带数据，但是要消耗掉一个序号）
	2、第二次握手
		服务器收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化序列号ISN。同时把客户端的ISN+1
		作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_REVD状态。
		在确认报文段中，SYN=1，ACK=1，确认号ack=x+1,初始化序号 seq=y
	3、第三次握手
		客户端收到SYN报文之后，会发送一个ACK报文，把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时
		客户端处于ESTABLISHED 状态。服务器收到ACK报文之后也处于ESTABLISHED状态，此时双方已建立起了连接。

		确认报文段：ACK=1，确认号ack=y+1,序号seq=x+1 (初始为seq=x,第二个报文段所以要+1),ack报文段可以携带数据，
		不携带数据则不消耗序号。

		在socket编程中，客户端执行connect()时，将触发三次握手，并在accept()函数中完成握手连接

		流程图参考：
			https://pic3.zhimg.com/80/v2-2a54823bd63e16674874aa46a67c6c72_1440w.jpg


	1.1、 为什么需要三次握手，两次不行吗？
	第一次握手：客户端发送网络包，服务端收到了。
	这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
	第二次握手：服务端发包，客户端收到了。
	这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力
	是否正常。
	第三次握手：客户端发包，服务端收到了。
	这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
	因此，需要三次握手才能确认双方的接收与发送能力是否正常

	1.2 什么是半连接队列？
		服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。
		当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。
	 补充：关于SYN-ACK 重传次数的问题：
		服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

	1.3 三次握手过程中可以携带数据吗？
		其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据
		为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。
		也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED
		状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

2、四次挥手

		建立一个连接需要三次握手，而终止一个连接需要经过四次挥手，这是由于TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另外一端数据的能力。
		TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。
		刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。

		四次挥手的过程如下：

		第一次挥手：
			客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1 状态。
		即发出连接释放报文段（FIN=1，序号seq=u）,并停止在发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待
		服务端的确认。

		第二次挥手：
			服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1 作为ACK报文的序列号值，表明已经收到了客户端的报文了，
			此时服务端处于CLOSE_WAIT状态。

			即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

		第三次挥手：
			如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
			即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

		第四次挥手
			客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

			即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

			说明：
				收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

				在socket编程中，任何一方执行close()操作即可产生挥手操作。
			流程图参考：https://pic2.zhimg.com/80/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg

	2.1 挥手为什么四次
        由于Tcp是连接是全双工的，允许数据在两个方向上同时传输。客户端和服务端的两次挥手，也就是客户端和服务端分别释放连接的过程，
        客户端在最后一次确认之后，还要等待2MSL的时间，主要有两个原因，一个是为了让B能够按照正常步骤进入CLOSED状态。二是为了防止
        已经失效的请求报文出现在下次请求中。 （可以介绍2.2为什么要等待）

	2.2 四次挥手释放连接时，等待2MSL的意义? 和 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？
		说明：MSL可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

		理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。
		所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

		等待2MSL的主要目的总结：
			1、保证客户端发送的最后一个ACK报文段能够到达服务端。
				为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，
				接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

			2、防止“已失效的连接请求报文段”出现在本连接中。
				客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

    2.3 三次握手时失败了会发生什么？
        1、说明在第二次握手正常，客户端和服务器端接口和发送能力正常。并且客户端已经是established状态，连接建立成功，可以单方面的向服务器TCP发送数据。
        2、第三次握手失败，服务器迟迟没有收到ACK,他的默认状态就是SYN_RCVD。并且根据TCP的超时重传机制，会等待，3，6，12秒重新发送第二组握手的分组，
        以便客户端重新发送第三次分组。若干次后服务器还没有收到ACK应答，那么服务器将会关闭这个连接。
        3、如果在第三次握手的ACK丢失的情况下客户端向服务端发送了数据，那么服务端将会以（RST包 重置响应）

    2.4 每次握手失败对应的措施：
        1、如果第一次的SYN传输失败，两端都不会申请资源。如果一段时间后之前的SYN发送成功了，
        这时客户端只会接收他最后发送的SYN的SYN+ACK回应，其他的一概忽略，服务端也是如此，会将之前多申请的资源释放了。
        2、如果服务端发送的SYN+ACK传输失败，客户端由于没有收到这条响应，不会申请资源，
        虽然服务端申请了资源，但是迟迟收不到来自客户端的ACK，也会将该资源释放。
        3、如果第三次握手的ACK传输失败，导致服务端迟迟没有收到ACK，就会释放资源，
            这时候客户端认为自己已经连接好了，就会给服务端发送数据，服务端由于没有收到第三次握手，
            就会以RST包对客户端响应。但是实际上服务端会因为没有收到客户端的ACK多次发送SYN+ACK，次数是可以设置的，
            如果最后还是没有收到客户端的ACK，则释放资源。

补充知识：
    OSI七层模型：
        应用层（http/https） -》 表示层（命令的解释/加密/解密） =》 会话层（会话控制&远程寻址） -》传输层（tpc/udp） -》网络层(ip) -》数据链路层 -》物理层

     TCP/IP 概念层模型
        应用层 -》 传输层（TCP/UDP协议）-》网络层 -》 链路层


TCP/IP 和 HTTP/HTTPS 区别

1、TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。
    eg: 比如你需要访问一个网页，浏览器会先生成HTTP的数据包，然后交给传输层去建立连接。

HTTP 和 HTTPS

1、什么是HTTPS
	HTTPS是在HTTP上建立SSL/TLS加密层，并对传输数据进行加密，是HTTP协议的安全版。

	TLS 是 SSL的升级版，TLS主要对加密做了增强。


2、HTTP存在的问题

	1、HTTP通信使用明文（不加密），内容可能被窃听。

	2、HTTP 无法验证报文的完整性，可能遭篡改

		所谓报文的完整性也是指报文信息的准确度。由于HTTP协议无法证明你通信的报文完整性，因此，在请求或响应送出之后直到对方
		接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。

	3、HTTP无法验证通信双方的身份，因此可能遭遇伪装。
		HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。
		另外，服务器只要接收到请求，不管对方是谁都会返回一个响应。因此，HTTP协议无法验证通信双方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，而用户无法擦觉。


3、HTTPS解决了上述问题
	1、数据隐私性。（内容经过对成加密，每个连接生成一个唯一的加密密钥）
	2、数据完整性。（内容传输经过完整性校验，通过ssl和tsl hash算法进行完整性的校验。相同的数据在hash时会得到相同的值，因此根据这个特性，来验证数据的完整性。）
	3、身份认证。（第三方无法伪造服务端（客户端）身份）



4、HTTP和HTTPS 层次

	HTTP(传输层协议)					HTTPS（传输层协议）
	TCP                             SSL/TLS
	IP                              TCP
									IP


   HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL协议的功能实现主要依赖于三类基本算法。散列函数，对称机密和非对称加密。
   1、利用非对称加密实现身份认证和密钥协商
   2、利用对称加密算法采用协商的密钥对数据进行加密
   3、基于散列函数验证信息的完整性。

   参考结构图：
   https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/TLS:SSL%E6%B5%81%E7%A8%8B%E5%9B%BE.png



5、HTTPS解决内容可能被窃听的问题 - 加密
	HTTPS 使用对称加密+ 非对称加密 两者并用的混合加密机制
	具体做法： 发送密文的一方使用对方的公钥进行加密处理 ”对称的密钥“，然后对方用自己的私钥解密拿到”对称的密钥“，这样可以确保
	交换的密钥是安全的前提下，使用对称加密方式进行通信。



6、解决报文可能遭篡改问题 - 数字签名
	HTTPS使用 数字签名，解决报文可能被篡改。
	具体流程：
		1、发送者将一段报文先用HASH 函数生成消息摘要，然后用发送着的私钥加密生成数字签名。并且将数字签名与原报文一起发送给接收者。
		2、接送着用发送者的公钥解密被加密的摘要信息，然后用HASH函数对接收到的原文生成一个摘要信息，并与上一步接收到的摘要信息进行对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。


7、解决通信方身份可能被伪装的问题 —— 数字证书
	HTTPS使用 数字证书 解决通信方身份可能被伪装的问题
	数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上

	我们来介绍一下数字证书认证机构的业务流程：

	1、服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;

	2、CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;

	3、如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;

	4、客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;

	5、客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。

	6、客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法


8、HTTPS工作流程

	参考流程图：https://github.com/zlbonly/simple-go-algorithm/blob/master/pics/https%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg
	1.Client发起一个HTTPS（比如 https://juejin.im/user）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。

	2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。

	3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。

	4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。

	5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。

	6.Server使用对称密钥加密“明文内容A”，发送给Client。

	7.Client使用对称密钥解密响应的密文，得到“明文内容A”。

	8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。



 9、补充知识 对称加密和非对称加密
 	非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。
 	非对称加密效率低。




1、浏览器输入URL 返回页面的全过程 （分别介绍八大步骤）

	1.根据域名，进行DNS域名解析；
	2.拿到解析的IP地址，建立TCP连接；
	3.向IP地址，发送HTTP请求；
	4.服务器处理请求；
	5.返回响应结果；
	6.关闭TCP连接；
	7.浏览器解析HTML；
	8.浏览器布局渲染；

场景：用户在浏览器输入网址：http://live.qq.com，其解析过程如下


1、DNS域名解析
	先介绍域名结构
		1、http://live.qq.com 实际的域名是 http://live.qq.com.
		根域名(.) => 顶级域名(.com 或者.net) => 次级域名.qq => live(三级域名或者主机名，用户可以自行注册的)

	1、浏览器将会检查缓存中有没有这个域名对应的解析过的IP地址，如果有该解析过程
	将会结束
	2、如果用户的浏览器中缓存中没有，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射关系，完成域名解析。
	3、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系或缓存信息，如果有，直接返回给浏览器，完成域名解析。
	4、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，则会首先找本地DNS服务器，一般是公司内部的DNS服务器，此服务器收到查询，如果此本地DNS服务器查询到相对应的IP地址映射或者缓存信息，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
	5、若没有，则操作系统将域名发送至 本地域名服务器- -（递归查询方式），本地域名服务器 查询自己的DNS缓存，查找成功则返回结果，否则，（以下是迭代查询方式）

		5.1 本地域名服务器 向根域名服务器（其虽然没有每个域名的具体信息，但存储了负责每个域，如com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，根域名服务器返回com域的顶级域名服务器的地址

		5.2 本地域名服务器 向com域的顶级域名服务器发起请求，返回baidu.com权限域名服务器（权限域名服务器，用来保存该区中的所有主机域名到IP地址的映射）地址

		5.3 本地域名服务器 向baidu.com权限域名服务器发起请求，得到www.baidu.com的IP地址

    6、本地域名服务器 将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来

	7、操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来

	至此，浏览器已经得到了域名对应的IP地址。

2、拿到解析的IP地址，建立TCP连接；（叙述三次握手流程）

3、向IP地址，发送HTTP请求；
	    浏览器会对请求进行包装，包装成请求报文.使用Get/Post等请求方式进行请求。

4、服务器收到请求并响应HTTP请求
	此步骤一般nginx 会做 反向代理和 负载均衡

	1、正向代理 和 反向代理
		1、正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。

		demo: vpn 就是一种正向代理。VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机
		2、反向代理
			1、反向代理和正向代理的区别就是：正向代理代理客户端，反向代理代理服务器。
			2、反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。

	2、负载均衡
		nginx 一般使用轮询 和权重  将请求分配到不同的服务器上。

	3、浏览器请求报文到达服务器之后，服务器接口会对请求报文进行处理，执行接口对应的代码，处理完成后响应客户端。
5、服务器返回结果

	需要关注一个报文头--accept。accept代表发送端（客户端）希望接受的数据类型，这是浏览器自动封装的请求头。如果服务器返回的content-type是accept中的任何一个，浏览器都能解析，并直接展示在网页上。

	顺道介绍一下状态码： 1xx,2xx,3xx,4xx,5xx。

6、关闭TCP连接（叙述四次握手）

7.浏览器解析HTML 和 8.浏览器布局渲染；
    浏览器会根据相应的content-type字段对响应字符串进行解析。能够解析并成功解析就显示，能够解析但解析错误就报错，不能解析就下载


UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议。
它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。
由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。

理论上udp很适合做直播，丢包了一两帧也不会影响用户体验，但是在流量上和及时性上比较好。
但是目前的直播方案上行都是采用rtmp 或者flv ，底层都是使用tcp.


1、Tcp 粘包和拆包
由于TCP传输协议面向流的，没有消息保护边界。一方发送的多个报文可能会被合并成一个大的报文进行传输，这就是粘包;也可能发送的一个报文，可能会被拆分成多个小报文，这就是拆包。

2、TCP粘包原因分析
	导致TCP粘包的原因，可能是发送方的原因，也有可能是接受方的原因。
	1、发送方
		由于TCP需要尽可能高效和可靠，所以TCP协议默认采用Nagle算法，以合并相连的小数据包，再一次性发送，以达到提升网络传输效率的目的。但是接收方并不知晓发送方合并数据包，而且数据包的合并在TCP协议中是没有分界线的，所以这就会导致接收方不能还原其本来的数据包。
		1、应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
		2、应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。

	2、接收方
		TCP是基于“流”的。网络传输数据的速度可能会快过接收方处理数据的速度，这时候就会导致，接收方在读取缓冲区时，缓冲区存在多个数据包。在TCP协议中接收方是一次读取缓冲区中的所有内容，所以不能反映原本的数据信息。
		4、接收方法不及时读取套接字缓冲区数据，这将发生粘包。

		3、进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包。

	补充：MTU (Maxitum Transmission Unit,最大传输单元)是链路层对一次可以发送的最大数据的限制。MSS(Maxitum Segment 	 Size,最大分段大小)是TCP报文中data部分的最大长度，是传输层对一次可以发送的最大数据的限制。

3、解决TCP粘包

	1、Nagel 主要是为了解决带宽，现在的网络带宽提升不少，可以仅用Nagle算法。
	2、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
	3、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
	4、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。
4、UDP不存在粘包
由于UDP不是面向‘流’的，而且UDP是具有消息边界的。也就是说UDP的发送的每一个数据包都是独立的。所以UDP并不存在粘包的问题。



close_wait： 被动关闭的一方 会出现close_wait.
		主动关闭的一方发出FIN包，被动关闭的一方响应ACK包，此时，这个时候被动关闭的一方就进入了CLOSE_WAIT状态
		如果一切正常，稍后被动关闭的一方也会发出FIN包，然后进入LAST_ACK状态。
time_wait: 主动关闭的一方 会出现time_wait


10 结合项目说说项目中出现大量close_wait和time_wait。
项目中出现大量大量close_wait 原因及解决思路？

1、项目一问题场景，项目的“抽奖服务”场景  一次Mysql主动关闭，导致服务出现了大量的close_wait

	之前碰到线上一个socket资源不断被打满的情况。服务出现504

	抽奖服务底层是使用Golang开发的，线上已经接近一年，提供给PHP调用，主要的底层资源是DB/Redis/MQ

		服务的架构大致是
		负载均衡器 -》 server1 和server2 => DB 负载均衡器 =〉 db1 和db2

   1、刚开始以为是可能是服务长时间没有重启，内心的一些问题导致了 内存泄漏，没多想找运维进行了重启
   	但是没有解决问题，有抽奖活动时，还是出现了问题，意识到不是重启能解决的。
   2、socket资源被打满，之前从来没有出现过，今天突然出现，怀疑是不是请求量最太大压垮服务器了，查看过qps以后，
   发现量虽然增加，但是在服务承受范围内，排除服务器压垮的猜想
   3、两台机器同时出现了故障，重启一台，另一台也会得到缓解，初步推断出时底层依赖的资源出现了问题。

   			1、通过 netstat -na | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'查看各个连接状态及数量发现大部分连接处于close_wait状态。

  			2、 然后通过netstat -an 命令检查连接端口的详情。发现了3306 mysql端口出现了大量的close_wait

  			3、使用tcpdump 进行抓包分析3306端口的包请求过程
  			发现，关闭连接只有两条数据：
  				1、mysql给服务发送了FIN 包，服务器也响应了，但是被动关闭的抽奖服务，没有继续FIN，导致一直处于CLOSE_WAIT 状态。



			4、由于代码之前不是我维护的，也是刚接手golang服务，业务逻辑都不是很清楚，因此谨慎 使用perf
			生成了火焰图，把所有的火焰图绘制出现了。
			分析火焰图 发现存在请求时间长的sql,以及没有commit 和 rollback 的事务。


			5、找到代码发现 在事务里面 有个 判断 data == nil  后直接return 了，没有对事务进行rollback;
				顺手优化了下请求时间长的sql

   		总结：由于那一行代码没有对事务进行回滚，导致服务端没有主动发起close。因此 MySQL负载均衡器 在达到 60s 的时候主动触发了close操作，但是通过tcp抓包发现，服务端并没有进行回应，这是因为代码中的事务没有处理，因此从而导致大量的端口、连接资源被占用


  分析close_wait流程：
  	1、close_wait 大部分都是由服务器端代码造成的，可以先通过netstat命令分析tcp各个连接的状态，然后使用tcpdump抓包分析，
  	然后perf获取火焰图，定位到具体的业务场景及代码，去解决问题。


2、大量time_wait 造成的影响。
	1、在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket 处于time_wait状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。
	主要原因：
		1、高并发让服务器在短时间范围内同时占用大量的端口。而端口有0 ~ 65535的范围。刨除系统和其他服务要用的，剩下的就更瘦啊好了。

		解决方案：
			1、通过调节系统参数。打开系统的TIMEWAIT 重用和快速回收
			2、不使用短连接，使用长连接，例如使用连接池 。 例如redis 中使用pconnect(长连接，使用后连接不是释放) 是不是使用connect

