
一、逃逸分析

   1、缘起
   前段时间跟项目组leader聊到golang编码规范时，我提到一个问题。
   我：“golang函数传参是不是应该跟c一样，尽量不要直接传结构体，而要传结构体指针？“
   leader：“不对，咱们项目很多都是直接传结构体的。“
   我：“那样不会造成不必要的内存copy开销吗？”
   leader：“确实会有，但这样可以减小gc压力，因为传值会在栈上分配，而一旦传指针，结构体就会逃逸到堆上。“
   我：“有道理。。。“
   由于之前是搞java的，关于逃逸分析在golang的上规则还不是很熟，因此，后来在心里一直记得：
   “一旦将某个局部变量以指针的方式传出，该变量就会逃逸到堆”。
   但是我内心还是对这种说法一直存在疑惑，所以一直想找个机会好好学习一下

   2、什么是逃逸分析
      在计算机语言编译器优化原理中，逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中
      分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用，这种现象称作指针（或者引用）的逃逸。

    说白了就是：逃逸分析是编译器用于决定变量分配到栈还是堆上的一种行为。
      go在一定程度上消除了堆和栈的区别，因为go在编译的时候进行了逃逸分析，来决定一个对象放到栈上还是堆上，不逃逸的对象放栈上，可能逃逸的放到堆上

   3、逃逸分析场景
   准备知识：
    goland的逃逸分析是在编译期完成的，并且Goland 的逃逸分析只针对指针。一个值引用如果没有被取地址，那么它永远不可能逃逸。

    go run -gcflags "-m -l"
    情景1：在某个函数中new 或 字面量创建出的变量，将其指针作为函数返回值，则一定发生逃逸。
    demo1:
        func test() *User{
            a := User{}
            return &a
        }

    情景2：被指针类型的slice，map 和 chan 引用的指针一定发生逃逸。
       备注：在stack overflow有人提问为什么使用指针的chan比使用值的chan慢30%，就是因为使用指针的chan发生了逃逸，gc拖慢了速度。
       a := make([]*int,1)
       b := 12
       a[0] = &b

    情景3：逃逸指针引用逃逸
        被已经逃逸的变量引用的指针，一定发生逃逸。这里是fmt.Printf里，func newPrinter() *pp {…} pp指针逃逸了，所以传入的word被一个逃逸的指针引用了，必然逃逸。
    情景4：栈空间不足逃逸
           当对象大小超过的栈帧大小时（详见go内存分配），变量对象发生逃逸被分配到堆上。

           对于 Go 语言来说，运行时(runtime) 尝试在 goroutine 需要的时候动态地分配栈空间，goroutine 的初始栈大小为 2 KB。当 goroutine 被调度时，会绑定内核线程执行，栈空间大小最也不会超过操作系统的限制。
           对 Go 编译器而言，超过一定大小的局部变量将逃逸到堆上，不同的 Go 版本的大小限制可能不一样。

    情景5:动态类型逃逸
          当对象不确定大小或者被作为不确定大小的参数时发生逃逸。

    必然不会逃逸
    • 指针被未发生逃逸的变量引用；
    • 仅仅在函数内对变量做取址操作，而未将指针传出



    4、逃逸分析的好处
        1、减少gc压力，不逃逸的对象分配到栈上，当函数返回时就回收了资源，不需要gc标记清除
        2、逃逸分析后可以确定那变量可以分配到栈上，栈的分配比堆快，因此性能更好。
